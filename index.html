<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>微凉</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="白日梦重度患者">
<meta property="og:type" content="website">
<meta property="og:title" content="微凉">
<meta property="og:url" content="https://breewf.github.io/index.html">
<meta property="og:site_name" content="微凉">
<meta property="og:description" content="白日梦重度患者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="haiygao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/breewf.github.io/atom.xml" title="微凉" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/breewf.github.io/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/breewf.github.io/css/style.css">

  
    
<link rel="stylesheet" href="/breewf.github.io/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/breewf.github.io/" id="logo">微凉</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/breewf.github.io/" id="subtitle">Android</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/breewf.github.io/">Home</a>
        
          <a class="main-nav-link" href="/breewf.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/breewf.github.io/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://breewf.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ViewBinding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2021/07/31/ViewBinding/" class="article-date">
  <time class="dt-published" datetime="2021-07-31T09:20:00.000Z" itemprop="datePublished">2021-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2021/07/31/ViewBinding/">ViewBinding</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Android绑定View的发展史"><a href="#Android绑定View的发展史" class="headerlink" title="Android绑定View的发展史"></a>Android绑定View的发展史</h2><p>从Android系统诞生至今，在代码中findView一直是Android开发者无法绕开的一道程序。从最初的findViewbyId到如今炙手可热的ViewBinding，期间涌现出了许多findView的方式，它们让findView变得更加简单，也让我们的代码变得更加简洁。但随着Android新技术的发展，这些findView的方法也正在被一个一个的抛弃。本节内容我们就来回顾一下Android开发中findView的发展史。</p>
<h3 id="findViewById"><a href="#findViewById" class="headerlink" title="findViewById"></a>findViewById</h3><p>findViewById是Android开发中最原始，也是最基础的一种获取View的方法。它由Google官方提供，在Android开发生态的早期也是唯一一种能够获取View的方式。虽然它使用简单且根正苗红，贯穿古今，但由于高度重复的代码结构深受开发者诟病。在一个复杂布局的页面仅仅是findViewById的代码就很多。开发者无时无刻不想着弃用这一方案，因此后续衍生出了多种获取View的方式来简化代码。但万变不离其宗，归根结底，这些方式最终都还是通过findViewById来实现的。</p>
<h3 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h3><p>就在大家都在唾弃findViewById的大量重复代码时，一个插件横空出世。它通过一个BindView注解，传入一个Resource Id就能轻松获取到Id对应的View。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">  @BindView(R.id.text_view) TextView mTextView;</span><br><span class="line"> </span><br><span class="line">     @Override</span><br><span class="line">     protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">         super.onCreate(savedInstanceState);</span><br><span class="line">         setContentView(R.layout.activity_main);</span><br><span class="line">         ButterKnife.bind(this);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它就是红极一时，时至今日大家依然还在用着的ButterKnife。ButterKnife通过Java编译时注解处理器，在编译时自动生成findViewById的代码。例如，上边的例子通过ButterKnife会生成一个MainActivity_ViewBinding 类，在这个类中通过findViewById为mTextView赋值，其代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity_ViewBinding implements Unbinder &#123;</span><br><span class="line">  private MainActivity target;</span><br><span class="line"></span><br><span class="line">  @UiThread</span><br><span class="line">  public MainActivity_ViewBinding(MainActivity target) &#123;</span><br><span class="line">    this(target, target.getWindow().getDecorView());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @UiThread</span><br><span class="line">  public MainActivity_ViewBinding(MainActivity target, View source) &#123;</span><br><span class="line">    this.target = target;</span><br><span class="line"></span><br><span class="line">    target.mTextView = Utils.findRequiredViewAsType(source, R.id.text_view, &quot;field &#x27;mTextView&#x27;&quot;, TextView.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  @CallSuper</span><br><span class="line">  public void unbind() &#123;</span><br><span class="line">    MainActivity target = this.target;</span><br><span class="line">    if (target == null) throw new IllegalStateException(&quot;Bindings already cleared.&quot;);</span><br><span class="line">    this.target = null;</span><br><span class="line"></span><br><span class="line">    target.mTextView = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一操作省去了开发者手动编写findViewById的时间，大大简化了代码，同时提高了开发效率。在开发者看来ButterKnife不得不说是一个神器，以至于到后来成了Android项目开发的标配。</p>
<p>但是Android Studio更新到了4.1版本后，发现项目中使用ButterKnife注解id的代码出现了警告，警告信息如下：</p>
<blockquote>
<p>Resource IDs will be non-final in Android Gradle Plugin version 5.0, avoid using them as annotation attributes</p>
</blockquote>
<p>从警告信息中可以看到在<strong>Gradle 5.0的插件中Resource的Id值将不会再是final类型</strong>，<strong>因此应该避免在注解属性中使用Id</strong>。这意味着当我们把Gradle插件升级到5.0版本之后ButterKnife将无法再被使用！同时，我们在ButterKnife的官方文档上也看到了ButterKnife被标注弃用的信息：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0736b1397ab947ff9a6ed20ce2226f47~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>陪伴我们多年，曾经辉煌一时，不可一世的ButterKnife也要寿终正寝，即将迎来它生命的终点。</p>
<h3 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h3><p>DataBinding是Google官方在2015年谷歌I/O大会上发布的一个数据绑定框架，它并非专为findView而生，而是作为MVVM架构的双向绑定数据的工具。findView的功能仅仅是DataBinding的一个附赠品。</p>
<p>开发者一般会在MVVM架构的项目中使用DataBinding来获取View。但是它也有很多诟病，比如需要修改xml的结构，在xml外部嵌套一个标签。并且很多情况下需要手动build才能生成DataBinding相关类。诸如此类问题，自然不会得到开发者的青睐。</p>
<p>关于DataBinding的详细使用在这里不做探讨。</p>
<h3 id="Kotlin-Android-Extensions"><a href="#Kotlin-Android-Extensions" class="headerlink" title="Kotlin Android Extensions"></a>Kotlin Android Extensions</h3><p>2017年Google I/O开发者大会中，Google宣布Kotlin成为Android开发的一级语言，自此，Kotlin “转正”与Java并驾齐驱。而JetBrain推出的Kotlin Android Extension(以下简称KAE)插件成为了有史以来最简单的获取View的方法，简单到无需任何代码，直接通过id作为View使用。这一功能足以让所有Android开发者抓狂，纷纷感叹这才是findView的未来啊，终于可以和裹挟开发者十多年的findViewById说拜拜了！ 作为一个Android开发者，不知道你是否会好奇Kotlin是如何将Id作为View的？我们不妨写一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        textView.text = &quot;Test&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布局文件中TextView的id设置为“textView”，则在Activity中可以直接将textView作为一个TextView来使用。我们通过Android Studio的工具将kotlin的字节码反编译成Java代码看下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adfef7fa3aef45d7960649a7da1a3c78~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>通过上述操作，打开kotlin的字节码后，再通过Decompile反编译成Java代码，则会得到如下图所示的结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89242a36d09045f38af57b5dcb0e6165~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>通过反编译得到的Java代码我们发现Kotlin的这一操作其实也是通过findViewById实现的。只是通过插件的方式让我们感觉上是用了View的Id。</p>
<p>通过Kotlin的扩展插件来find view,无疑是一种优秀的方案。但这一方案并不是无懈可击。它存在以下几个缺点：</p>
<ul>
<li>类型安全：res下的任何id都可以被访问，有可能因访问了非当前Layout下的id而出错</li>
<li>空安全：这主要体现在配置中的对应布局不全时，运行时可能出现NPE</li>
<li>兼容性：只能在kotlin中使用，java不友好</li>
<li>局限性：不能跨module使用</li>
</ul>
<p>也正是这几个缺点导致了KAE的大溃败。随着Google对亲儿子ViewBinding的大力推广，KAE最终也招架不住，只能缴械投降—Jetbrains在官网宣布废弃KAE，并推荐开发者使用ViewBinding。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48eb63b0434a41b5a8d4bd7b54154651~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h3><p>ViewBinding是Google在2019年I/O大会上公布的一款Android视图绑定工具。它的使用方式有点类似DataBinding，但相比DataBinding，ViewBinding是一个更轻量级、更纯粹的findViewById的替代方案。它具有以下几个优点：</p>
<ul>
<li>类型安全: ViewBinding会基于布局中的View生成类型正确的属性。比如，在布局中放入了一个 TextView ，视图绑定就会暴露出一个 TextView 类型的属性供开发者使用。</li>
<li>空安全：ViewBinding会检测某个视图是不是只在一些配置下存在，并依据结果生成带有 @Nullable 注解的属性。所以即使在多种配置下定义的布局文件，视图绑定依然能够保证空安全。</li>
<li>ViewBinding生成的绑定类是一个Java类，并且添加了Kotlin的注解，可以很好的支持 Java 和 Kotlin 两种编程语言。</li>
</ul>
<p>同时，Google官方还给出了一个ViewBinding、ButterKnife以及KAE的对比，如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08acb2b737c6451f9742fb9fa46858e0~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="ViewBinding使用详解"><a href="#ViewBinding使用详解" class="headerlink" title="ViewBinding使用详解"></a>ViewBinding使用详解</h2><h3 id="开启ViewBinding"><a href="#开启ViewBinding" class="headerlink" title="开启ViewBinding"></a>开启ViewBinding</h3><p>Android Studio对于ViewBinding的支持是从3.6版本开始的，AS 3.6版本内置了Gradle插件。只需要在build.gradle中通过以下配置即可开启ViewBinding：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 需要 Android Gradle Plugin 3.6.0</span><br><span class="line">android &#123;</span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Android Studio 4.0 中，viewBinding 变成属性被整合到了 buildFeatures 选项中，所以配置要改成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Android Studio 4.0</span><br><span class="line">android &#123;</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        viewBinding = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果，你的项目存在多个模块，则需要在每个模块的gradle中添加上述配置。完成以上配置后ViewBinding会为所有布局文件自动生成对应的绑定类。且无须修改原有布局的 XML 文件，ViewBinding会根据现有的布局自动完成所有工作。</p>
<h3 id="在Activity中使用ViewBinding"><a href="#在Activity中使用ViewBinding" class="headerlink" title="在Activity中使用ViewBinding"></a>在Activity中使用ViewBinding</h3><p>首先编写activity_main.xml的布局文件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/text_view&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;Hello World!&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<p>完成后gradle插件会自动生成一个名为ActivityMainBinding的Java类，在Activity中通过ActivityMainBinding获取Binding实例，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        val binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.textView.text = &quot;Hello World&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewBinding与include标签"><a href="#ViewBinding与include标签" class="headerlink" title="ViewBinding与include标签"></a>ViewBinding与include标签</h3><p>在项目开发中，通常我们会使用include标签来简化布局文件，那么在使用了include标签的布局文件中，应该如何使用ViewBinding呢？且看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// activity_main.xml</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include</span><br><span class="line">        android:id=&quot;@+id/include&quot;</span><br><span class="line">        layout=&quot;@layout/layout_include&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// layout_include.xml</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_text&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;Hello World!&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<p>上述两个布局文件会分别生成ActivityMainBinding与LayoutIncludeBinding两个Java类，并且ActivityMainBinding类中通过组合依赖了LayoutIncludeBinding类。因此，使用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        val binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        // 从ActivityMainBinding中获取LayoutIncludeBinding</span><br><span class="line">        val include = binding.include</span><br><span class="line">        // 通过LayoutIncludeBinding为TextView赋值</span><br><span class="line">        include.tvText.text = &quot;Hello World&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果layout_include.xml文件位于子模块，经实践与以上代码的使用方式并无任何差异，但一定要在子模块中开启ViewBinding才行。</p>
<h3 id="ViewBinding在Fragment中的使用"><a href="#ViewBinding在Fragment中的使用" class="headerlink" title="ViewBinding在Fragment中的使用"></a>ViewBinding在Fragment中的使用</h3><p>在Fragment中使用ViewBinding与Activity中有些差异，这里为了简便，我们使用上述中的activity_main.xml作为Fragment的布局文件，则Fragment的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private lateinit var binding: ActivityMainBinding</span><br><span class="line">    override fun onCreateView(</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        savedInstanceState: Bundle?</span><br><span class="line">    ): View? &#123;</span><br><span class="line">        binding = ActivityMainBinding.inflate(inflater, container, false)</span><br><span class="line">        return binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onViewCreated(view, savedInstanceState)</span><br><span class="line">        binding.textView.text=&quot;Hello World&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewBinding在RecyclerView-Adapter中的使用"><a href="#ViewBinding在RecyclerView-Adapter中的使用" class="headerlink" title="ViewBinding在RecyclerView#Adapter中的使用"></a>ViewBinding在RecyclerView#Adapter中的使用</h3><p>布局文件不再贴出，直接看Adapter的代码，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TestAdapter : RecyclerView.Adapter&lt;TestViewHolder&gt;() &#123;</span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TestViewHolder &#123;</span><br><span class="line">        val binding =</span><br><span class="line">            ItemTestBinding.inflate(LayoutInflater.from(parent.context))</span><br><span class="line">        return TestViewHolder(binding)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: TestViewHolder, position: Int) &#123;</span><br><span class="line">        holder.binding.textView.text = &quot;Hello World&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getItemCount(): Int &#123;</span><br><span class="line">        return 10</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class TestViewHolder(var binding: ItemTestBinding) :</span><br><span class="line">        RecyclerView.ViewHolder(binding.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上几个实例可以看到ViewBinding的使用是非常简单的。而ViewBinding的实现原理也并不难，Gradle插件会根据布局文件在项目的build目录下生成相应的ViewBinding类，并且，最终也是通过findViewById来完成View的获取的。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6900229136199974926" >ButterKnife被弃用，ViewBinding才是findView的未来？<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6844904088128192525" >使用视图绑定替代 findViewById<i class="fas fa-external-link-alt"></i></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2021/07/31/ViewBinding/" data-id="ckrrknh4b00006p1n1mu1g0mj" data-title="ViewBinding" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-动画Animation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2021/07/31/%E5%8A%A8%E7%94%BBAnimation/" class="article-date">
  <time class="dt-published" datetime="2021-07-31T08:20:00.000Z" itemprop="datePublished">2021-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2021/07/31/%E5%8A%A8%E7%94%BBAnimation/">动画Animation</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android动画大致可以分为<strong>帧动画（Frame Animation）</strong>、<strong>补间动画（Tween Animation）</strong>、<strong>属性动画（Property Animation）</strong>、<strong>转场动画（Transition Animation）</strong>。 </p>
<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><blockquote>
<p>逐帧动画是一种常见的动画形式（<strong>Frame By Frame</strong>），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。 因为逐帧动画的帧序列内容不一样，不但给制作增加了负担而且最终输出的文件量也很大，但它的优势也很明显：<strong>逐帧动画具有非常大的灵活性</strong>，几乎可以表现任何想表现的内容，而它类似与电影的播放模式，很适合于表演细腻的动画。例如：人物或动物急剧转身、 头发及衣服的飘动、走路、说话以及精致的3D效果等等。</p>
</blockquote>
<p>在Android开发中，使用帧动画，他的核心类是 <strong>AnimationDrawable</strong>。</p>
<p>有两种方式可以使用帧动画，一种是写入静态 xml 获得 AnimationDrawable，还有一种是创建 AnimationDrawable 对象以后，对其添加关键帧。</p>
<h3 id="xml-资源文件创建"><a href="#xml-资源文件创建" class="headerlink" title="xml 资源文件创建"></a>xml 资源文件创建</h3><p>在 xml 中的 drawable 新建一个根节点为 <strong>animation-list</strong> 动画的资源，再将每一帧动画按顺序摆放。</p>
<p>例如，新建一个 anim_frame.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:oneshot=&quot;false&quot;&gt;</span><br><span class="line">    &lt;!-- oneshot 是否只播放一次 --&gt;</span><br><span class="line">    &lt;!-- duration 持续时间 单位毫秒 --&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/farm_0&quot; android:duration=&quot;100&quot; /&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/farm_1&quot; android:duration=&quot;100&quot; /&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/farm_2&quot; android:duration=&quot;100&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure>

<p>属性值含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>oneshot</td>
<td>是否只播放一次 false: 只播放一次; true:循环播放</td>
</tr>
<tr>
<td>drawable</td>
<td>图片资源</td>
</tr>
<tr>
<td>duration</td>
<td>播放时间</td>
</tr>
</tbody></table>
<p>添加到 ImageView 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imageView = findViewById(R.id.image);</span><br><span class="line">imageView.setImageResource(R.drawable.anim_frame);</span><br><span class="line">AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getDrawable();</span><br><span class="line">animationDrawable.start();</span><br></pre></td></tr></table></figure>

<h3 id="代码创建"><a href="#代码创建" class="headerlink" title="代码创建"></a>代码创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">imageView = findViewById(R.id.image);</span><br><span class="line">AnimationDrawable animationDrawable1 = new AnimationDrawable();</span><br><span class="line">animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_1 ),200);</span><br><span class="line">animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_2 ),200);</span><br><span class="line">animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_3 ),200);</span><br><span class="line">animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_4 ),200);</span><br><span class="line">animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_5 ),200);</span><br><span class="line">animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_6 ),200);</span><br><span class="line">animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_7 ),200);</span><br><span class="line">animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_8 ),200);</span><br><span class="line">animationDrawable1.setOneShot(true);</span><br><span class="line">imageView.setImageDrawable(animationDrawable1);</span><br><span class="line">animationDrawable1.start();</span><br></pre></td></tr></table></figure>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：使用简单、方便</li>
<li>缺点：因为是多张图片逐帧播放的，对于内存的消耗比较大，容易出现卡顿，甚至OOM（ java.lang.OutOfMemoryError ），因为会使用大量 &amp; 尺寸较大的图片资源</li>
</ul>
<h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><blockquote>
<p>补间动画指的是做FLASH动画时，在两个关键帧中间需要做“补间动画”，才能实现图画的运动；插入补间动画后两个关键帧之间的插补帧是由计算机自动运算而得到的。</p>
</blockquote>
<p>在Android中则是通过使用 <strong>Animation</strong> 对 view 执行一系列转换来创建动画，通过对 view 执行旋转、淡出、平移和缩放等转换，达到动画的效果。</p>
<h3 id="补间动画的分类"><a href="#补间动画的分类" class="headerlink" title="补间动画的分类"></a>补间动画的分类</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>对应 Animation 子类</th>
<th>对应的 xml 属性</th>
</tr>
</thead>
<tbody><tr>
<td>Translate</td>
<td>平移动画</td>
<td>TranslateAnimation</td>
<td>translate</td>
</tr>
<tr>
<td>Scale</td>
<td>缩放动画</td>
<td>ScaleAnimation</td>
<td>scale</td>
</tr>
<tr>
<td>Rotate</td>
<td>旋转动画</td>
<td>RotateAnimation</td>
<td>rotate</td>
</tr>
<tr>
<td>Alpha</td>
<td>透明度动画</td>
<td>AlphaAnimation</td>
<td>alpha</td>
</tr>
<tr>
<td>Set</td>
<td>组合动画</td>
<td>AnimationSet</td>
<td>set</td>
</tr>
</tbody></table>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>补间动画的使用方式有两种：xml 和 代码动态设置</p>
<ul>
<li>xml 方式</li>
</ul>
<p>需要在 res/anim 文件夹下面创建对应的静态动画资源，再使用 <strong>AnimationUtils.loadAnimation</strong>(this, 资源ID) 的方式获取到 Animation 对象， 最后使用view.startAnimation(anim)的方式设置给需要添加动画效果的View。</p>
<ul>
<li>代码设置</li>
</ul>
<p>使用 Animation 的继承类，如 TranslateAnimation 等，设置需要的属性，最后使用view.startAnimation(anim)的方式设置给需要添加动画效果的View。</p>
<h3 id="透明度动画"><a href="#透明度动画" class="headerlink" title="透明度动画"></a>透明度动画</h3><ul>
<li>android:fromAlpha   动画开始的透明度，从0.0 - 1.0 ，0.0表示全透明，1.0表示完全不透明</li>
<li>android:toAlpha       动画结束时的透明度，也是从0.0 - 1.0 ，0.0表示全透明，1.0表示完全不透明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:fromAlpha=&quot;1.0&quot;</span><br><span class="line">    android:toAlpha=&quot;0.0&quot;&gt;</span><br><span class="line">&lt;/alpha&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> btn_alpha.setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    // 方式1 代码设置</span><br><span class="line">    /**</span><br><span class="line">        * 参数 1  fromAlpha  动画开始时的透明度</span><br><span class="line">        * 参数 2  toAlpha    动画结束时的透明度</span><br><span class="line">        */</span><br><span class="line">    val anim = AlphaAnimation(1f, 0f)</span><br><span class="line">    anim.duration = 1000</span><br><span class="line">    view_anim.startAnimation(anim)</span><br><span class="line"></span><br><span class="line">    // 方式2 xml 设置</span><br><span class="line">    val animation = AnimationUtils.loadAnimation(this, R.anim.alpha)</span><br><span class="line">    view_anim_2.startAnimation(animation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a412b4d785fa4c11a4d0a3e4f289ca61~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="旋转动画"><a href="#旋转动画" class="headerlink" title="旋转动画"></a>旋转动画</h3><ul>
<li>android:fromDegrees     开始旋转的角度位置，正值代表顺时针方向度数，负值代表逆时针方向度数</li>
<li>android:toDegrees         结束时旋转到的角度位置，正值代表顺时针方向度数，负值代表逆时针方向度数</li>
<li>android:pivotX               缩放起点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p</li>
<li>android:pivotY               缩放起点Y轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p</li>
</ul>
<blockquote>
<p>当为数值时，表示在当前View的左上角，即原点处加上50px，做为起始点；如果是50%，表示在当前控件的左上角加上自己宽度的50%做为起始点；如果是50%p，那么就是表示在当前的左上角加上父控件宽度的50%做为起始点</p>
</blockquote>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>距离动画所在view自身左边缘10像素</td>
</tr>
<tr>
<td>10%</td>
<td>距离动画所在view自身左边缘的距离是整个view宽度的10%</td>
</tr>
<tr>
<td>10%p</td>
<td>距离动画所在view父控件左边缘的距离是整个view宽度的10%</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:fromDegrees=&quot;0&quot;</span><br><span class="line">    android:pivotX=&quot;0&quot;</span><br><span class="line">    android:pivotY=&quot;0&quot;</span><br><span class="line">    android:toDegrees=&quot;360&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/rotate&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> //旋转</span><br><span class="line">btn_rotate.setOnClickListener &#123;</span><br><span class="line">    // 方式1 代码设置</span><br><span class="line">    val anim = RotateAnimation(0f, 360f,0f,0f)</span><br><span class="line">    anim.duration = 1000</span><br><span class="line">    view_anim.startAnimation(anim)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 方式2 xml 设置</span><br><span class="line">    val animation = AnimationUtils.loadAnimation(this, R.anim.rotate)</span><br><span class="line">    view_anim_2.startAnimation(animation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2f342ac4e5647b88ba3796c8f4619b7~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="缩放动画"><a href="#缩放动画" class="headerlink" title="缩放动画"></a>缩放动画</h3><ul>
<li>android:fromXScale    起始的X方向上相对自身的缩放比例，浮点值，比如1.0代表自身无变化，0.5代表起始时缩小一倍，2.0代表放大一倍</li>
<li>android:toXScale        结尾的X方向上相对自身的缩放比例，浮点值</li>
<li>android:fromYScale    起始的Y方向上相对自身的缩放比例，浮点值</li>
<li>android:toYScale        结尾的Y方向上相对自身的缩放比例，浮点值</li>
<li>android:pivotX            缩放起点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p</li>
<li>android:pivotY           缩放起点Y轴坐标，取值及意义跟android:pivotX一样</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:fromYScale=&quot;1.0&quot;</span><br><span class="line">    android:toYScale=&quot;0.0&quot;</span><br><span class="line">    android:fromXScale=&quot;1.0&quot;</span><br><span class="line">    android:toXScale=&quot;0.0&quot;</span><br><span class="line">    android:pivotX=&quot;50%&quot;</span><br><span class="line">    android:pivotY=&quot;50%&quot;</span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">&lt;/scale&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//缩放</span><br><span class="line">btn_scale.setOnClickListener &#123;</span><br><span class="line">    // 方式1 代码设置</span><br><span class="line">    val anim = ScaleAnimation(</span><br><span class="line">        1.0f, 0f,</span><br><span class="line">        1.0f, 0f,</span><br><span class="line">        Animation.RELATIVE_TO_SELF, 0.5f,</span><br><span class="line">        Animation.RELATIVE_TO_SELF, 0.5f)</span><br><span class="line">    anim.duration = 1000</span><br><span class="line">    view_anim.startAnimation(anim)</span><br><span class="line"></span><br><span class="line">    // 方式2 xml 设置</span><br><span class="line">    val animation = AnimationUtils.loadAnimation(this, R.anim.scale)</span><br><span class="line">    view_anim_2.startAnimation(animation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70d1e46af20943d29ccf552e8e3532da~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="平移动画"><a href="#平移动画" class="headerlink" title="平移动画"></a>平移动画</h3><ul>
<li>android:fromXDelta    起始点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p</li>
<li>android:fromYDelta    起始点Y轴从标，可以是数值、百分数、百分数p 三种样式</li>
<li>android:toXDelta        结束点X轴坐标</li>
<li>android:toYDelta        结束点Y轴坐标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:fromXDelta=&quot;0&quot;</span><br><span class="line">    android:toXDelta=&quot;50%p&quot;</span><br><span class="line">    android:fromYDelta=&quot;0&quot;</span><br><span class="line">    android:toYDelta=&quot;0&quot;</span><br><span class="line">  &gt;</span><br><span class="line">&lt;/translate&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//平移</span><br><span class="line">btn_translate.setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    // 方式1 代码设置</span><br><span class="line">    val anim = TranslateAnimation(</span><br><span class="line">        Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT, 0.5f,</span><br><span class="line">        Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT, 0f</span><br><span class="line">    )</span><br><span class="line">    anim.duration = 1000</span><br><span class="line">    view_anim.startAnimation(anim)</span><br><span class="line"></span><br><span class="line">    // 方式2 xml 设置</span><br><span class="line">    val animation = AnimationUtils.loadAnimation(this, R.anim.translate)</span><br><span class="line">    view_anim_2.startAnimation(animation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0c06a75e59342ec97c672091e3842ec~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h3><p>set标签自已是没有属性的，他的属性都是从Animation继承而来，但当它们用于Set标签时，就会对Set标签下的所有子控件都产生作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;alpha</span><br><span class="line">        android:duration=&quot;1000&quot;</span><br><span class="line">        android:fromAlpha=&quot;1.0&quot;</span><br><span class="line">        android:toAlpha=&quot;0.0&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=&quot;1000&quot;</span><br><span class="line">        android:fromXDelta=&quot;0&quot;</span><br><span class="line">        android:fromYDelta=&quot;0&quot;</span><br><span class="line">        android:toXDelta=&quot;50%p&quot;</span><br><span class="line">        android:toYDelta=&quot;0&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> //组合动画</span><br><span class="line">btn_set.setOnClickListener &#123;</span><br><span class="line">    // 方式1 代码设置</span><br><span class="line">    // true : 所有子元素中共用同一插值器</span><br><span class="line">    val anim = AnimationSet(true)</span><br><span class="line">    anim.addAnimation(</span><br><span class="line">        TranslateAnimation(</span><br><span class="line">            Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT, 0.5f,</span><br><span class="line">            Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT, 0f</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    anim.addAnimation(AlphaAnimation(1f, 0f))</span><br><span class="line">    anim.duration = 1000</span><br><span class="line">    view_anim.startAnimation(anim)</span><br><span class="line"></span><br><span class="line">    // 方式2 xml 设置</span><br><span class="line">    val animation = AnimationUtils.loadAnimation(this, R.anim.set)</span><br><span class="line">    view_anim_2.startAnimation(animation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5abdbcb2c24c42568eebebe9ca3797ae~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="Animation类属性"><a href="#Animation类属性" class="headerlink" title="Animation类属性"></a>Animation类属性</h3><p>Animation类是所有动画（scale、alpha、translate、rotate）的基类。</p>
<ul>
<li>android:duration        动画持续时间，以毫秒为单位 </li>
<li>android:fillAfter          如果设置为true，控件动画结束时，将保持动画最后时的状态</li>
<li>android:fillBefore       如果设置为true,控件动画结束时，还原到开始动画前的状态</li>
<li>android:fillEnabled    与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态</li>
<li>android:repeatCount  重复次数</li>
<li>android:repeatMode  重复类型，有<strong>reverse</strong>和<strong>restart</strong>两个值，reverse表示倒序回放，restart表示重新放一遍，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作</li>
<li>android:interpolator  设定插值器，控制动画的变化速率</li>
</ul>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>使用 <strong>setAnimationListener</strong> 方法即可添加监视器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void setAnimationListener(AnimationListener listener) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">val anim = TranslateAnimation(</span><br><span class="line">        Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT, 0.7f,</span><br><span class="line">        Animation.RELATIVE_TO_PARENT, 0f, Animation.RELATIVE_TO_PARENT, 0f</span><br><span class="line">    )</span><br><span class="line">    anim.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">    anim.repeatMode = ValueAnimator.REVERSE</span><br><span class="line">    anim.duration = 2000</span><br><span class="line">    anim.setAnimationListener(object : Animation.AnimationListener &#123;</span><br><span class="line">        override fun onAnimationStart(animation: Animation?) &#123;</span><br><span class="line">            view_anim.text = &quot;补间动画开始&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onAnimationEnd(animation: Animation?) &#123;</span><br><span class="line">            view_anim.text = &quot;补间动画结束&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onAnimationRepeat(animation: Animation?) &#123;</span><br><span class="line">            view_anim.text = &quot;补间动画重复&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    view_anim.startAnimation(anim)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // 点击view触发 cancel 方法</span><br><span class="line">    view_anim.setOnClickListener &#123;</span><br><span class="line">    anim.cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补间动画的特点"><a href="#补间动画的特点" class="headerlink" title="补间动画的特点"></a>补间动画的特点</h3><p>值得注意的是：<strong>补间动画执行之后并未改变View的真实布局属性</strong>。</p>
<p>假设现在Activity中有一个 Button在屏幕上方，设置了平移动画移动到屏幕下方然后保持动画最后执行状态呆在屏幕下方。如果点击屏幕下方动画执行之后的Button是没有任何反应，而点击原来屏幕上方没有Button的地方却响应的是点击Button的事件，这一点是需要注意的。</p>
<blockquote>
<p>因为View动画是通过 ParentView 来不断调整 ChildView 的画布来实现的，比如平移，就是 ParentView 在 dispatchDraw 时发现这里有个平移动画，就调用了画布的 traslate 方法。也由于只是针对 ChildView 的画布进行操作，对 ChildView 的位置，大小等属性没有任何修改，所以才可以在View动画执行后，ChildView 的原位置响应点击事件。</p>
</blockquote>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>属性动画，通过修改 View 本身的属性，达到动画的效果。例如修改 view 的位置让他实现移动的效果，修改 view 的 alpha 实现透明度的效果。和补间动画有着本质的区别。</p>
<p>自Android 3.0版本开始，系统给我们提供了一种全新的动画模式，属性动画(property animation)，它的功能非常强大，弥补了之前补间动画的一些缺陷，几乎是可以完全替代掉补间动画了。</p>
<h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><p>ValueAnimator是整个属性动画机制当中最核心的一个类，属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等，确实是一个非常重要的类。</p>
<p>但是ValueAnimator的用法却一点都不复杂，我们先从最简单的功能看起吧，比如说想要将一个值从0平滑过渡到1，时长300毫秒，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);</span><br><span class="line">anim.setDuration(300);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>

<p>调用ValueAnimator的ofFloat()方法就可以构建出一个ValueAnimator的实例，ofFloat()方法当中允许传入多个float类型的参数，这里传入0和1就表示将值从0平滑过渡到1，然后调用ValueAnimator的setDuration()方法来设置动画运行的时长，最后调用start()方法启动动画。</p>
<p>动画监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);</span><br><span class="line">anim.setDuration(300);</span><br><span class="line">anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        float currentValue = (float) animation.getAnimatedValue();</span><br><span class="line">        Log.d(&quot;TAG&quot;, &quot;cuurent value is &quot; + currentValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>

<p>另外ofFloat()方法当中是可以传入任意多个参数的，因此我们还可以构建出更加复杂的动画逻辑，比如说将一个值在5秒内从0过渡到5，再过渡到3，再过渡到10，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator anim = ValueAnimator.ofFloat(0f, 5f, 3f, 10f);</span><br><span class="line">anim.setDuration(5000);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>

<p>当然也许你并不需要小数位数的动画过渡，可能你只是希望将一个整数值从0平滑地过渡到100，那么也很简单，只需要调用ValueAnimator的ofInt()方法就可以了，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator anim = ValueAnimator.ofInt(0, 100);</span><br></pre></td></tr></table></figure>

<p>ValueAnimator当中最常用的应该就是ofFloat()和ofInt()这两个方法了，另外还有一个ofObject()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator ofObject(TypeEvaluator evaluator, Object... values)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除此之外，我们还可以调用**setStartDelay()<strong>方法来设置动画延迟播放的时间，调用</strong>setRepeatCount()<strong>和</strong>setRepeatMode()**方法来设置动画循环播放的次数以及循环播放的模式，循环模式包括RESTART和REVERSE两种，分别表示重新播放和倒序播放的意思。</p>
</blockquote>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡。而ObjectAnimator则就不同了，它是可以直接对对象的属性进行动画操作的，比如说View的alpha属性。</p>
<p>虽说ObjectAnimator会更加常用一些，但是它其实是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。那么既然是继承关系，说明ValueAnimator中可以使用的方法在ObjectAnimator中也是可以正常使用的，它们的用法也非常类似，这里如果我们想要将一个TextView在5秒中内从常规变换成全透明，再从全透明变换成常规，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(textview, &quot;alpha&quot;, 1f, 0f, 1f);</span><br><span class="line">animator.setDuration(5000);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20150406161443130"></p>
<p>学会了这一个用法之后，其它的用法我们就可以举一反三了，那比如说我们想要将TextView进行一次360度的旋转，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(textview, &quot;rotation&quot;, 0f, 360f);</span><br><span class="line">animator.setDuration(5000);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20150406161421215"></p>
<p>那么如果想要将TextView先向左移出屏幕，然后再移动回来，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float curTranslationX = textview.getTranslationX();</span><br><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(textview, &quot;translationX&quot;, curTranslationX, -500f, curTranslationX);</span><br><span class="line">animator.setDuration(5000);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20150406161542959"></p>
<p>然后我们还可以TextView进行缩放操作，比如说将TextView在垂直方向上放大3倍再还原，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(textview, &quot;scaleY&quot;, 1f, 3f, 1f);</span><br><span class="line">animator.setDuration(5000);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20150406162608611"></p>
<h3 id="组合动画-1"><a href="#组合动画-1" class="headerlink" title="组合动画"></a>组合动画</h3><p>实现组合动画功能主要需要借助<strong>AnimatorSet</strong>这个类，这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法：</p>
<ul>
<li>after(Animator anim)   将现有动画插入到传入的动画之后执行</li>
<li>after(long delay)   将现有动画延迟指定毫秒后执行</li>
<li>before(Animator anim)   将现有动画插入到传入的动画之前执行</li>
<li>with(Animator anim)   将现有动画和传入的动画同时执行</li>
</ul>
<p>好的，有了这四个方法，我们就可以完成组合动画的逻辑了，那么比如说我们想要让TextView先从屏幕外移动进屏幕，然后开始旋转360度，旋转的同时进行淡入淡出操作，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, &quot;translationX&quot;, -500f, 0f);</span><br><span class="line">ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, &quot;rotation&quot;, 0f, 360f);</span><br><span class="line">ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, &quot;alpha&quot;, 1f, 0f, 1f);</span><br><span class="line">AnimatorSet animSet = new AnimatorSet();</span><br><span class="line">animSet.play(rotate).with(fadeInOut).after(moveIn);</span><br><span class="line">animSet.setDuration(5000);</span><br><span class="line">animSet.start();</span><br></pre></td></tr></table></figure>

<p>可以看到，这里我们先是把三个动画的对象全部创建出来，然后new出一个AnimatorSet对象之后将这三个动画对象进行播放排序，让旋转和淡入淡出动画同时进行，并把它们插入到了平移动画的后面，最后是设置动画时长以及启动动画。运行一下上述代码，效果如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20150406202028260"></p>
<h3 id="Animator监听器"><a href="#Animator监听器" class="headerlink" title="Animator监听器"></a>Animator监听器</h3><p>在很多时候，我们希望可以监听到动画的各种事件，比如动画何时开始，何时结束，然后在开始或者结束的时候去执行一些逻辑处理。这个功能是完全可以实现的，Animator类当中提供了一个<strong>addListener()<strong>方法，这个方法接收一个</strong>AnimatorListener</strong>，我们只需要去实现这个AnimatorListener就可以监听动画的各种事件了。</p>
<blockquote>
<p>ObjectAnimator是继承自ValueAnimator的，而ValueAnimator又是继承自Animator的，因此不管是ValueAnimator还是ObjectAnimator都是可以使用addListener()这个方法的。另外AnimatorSet也是继承自Animator的，因此addListener()这个方法算是个通用的方法。</p>
</blockquote>
<p>添加一个监听器的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">anim.addListener(new AnimatorListener() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void onAnimationStart(Animator animation) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void onAnimationRepeat(Animator animation) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void onAnimationCancel(Animator animation) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，我们需要实现接口中的四个方法，onAnimationStart()方法会在动画开始的时候调用，onAnimationRepeat()方法会在动画重复执行的时候调用，onAnimationEnd()方法会在动画结束的时候调用，onAnimationCancel()方法会在动画被取消的时候调用。</p>
<p>但是也许很多时候我们并不想要监听那么多个事件，可能我只想要监听动画结束这一个事件，那么每次都要将四个接口全部实现一遍就显得非常繁琐。没关系，为此Android提供了一个适配器类，叫作AnimatorListenerAdapter，使用这个类就可以解决掉实现接口繁琐的问题了，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">anim.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么如果我想监听动画结束这个事件，就只需要单独重写这一个方法就可以了，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">anim.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h3><p>ValueAnimator和ObjectAnimator除了通过ofInt(),ofFloat(),ofObject()创建实例外，还都有一个 ofPropertyValuesHolder() 方法来创建实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * valueAnimator的</span><br><span class="line"> */</span><br><span class="line">public static ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... values) </span><br><span class="line">/**</span><br><span class="line"> * ObjectAnimator的</span><br><span class="line"> */</span><br><span class="line">public static ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder... values)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static PropertyValuesHolder ofFloat(String propertyName, float... values)</span><br><span class="line">public static PropertyValuesHolder ofInt(String propertyName, int... values) </span><br><span class="line">public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,Object... values)</span><br><span class="line">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</span><br></pre></td></tr></table></figure>

<p>ObjectAnimator给我们提供了一个设置PropertyValuesHolder实例的入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder... values) </span><br></pre></td></tr></table></figure>

<ul>
<li>target：指需要执行动画的控件</li>
<li>values：是一个可变长参数，可以传进去多个PropertyValuesHolder实例，由于每个PropertyValuesHolder实例都会针对一个属性做动画，所以如果传进去多个PropertyValuesHolder实例，将会对控件的多个属性同时做动画操作。 </li>
</ul>
<p>用法示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder pvhXx = PropertyValuesHolder.ofFloat(&quot;x&quot;, startXx, endXx);</span><br><span class="line">PropertyValuesHolder pvhYy = PropertyValuesHolder.ofFloat(&quot;y&quot;, startYy, startYy);</span><br><span class="line"></span><br><span class="line">ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(danMuView, pvhXx, pvhYy);</span><br><span class="line">animator.setDuration(600);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<h3 id="Keyframe"><a href="#Keyframe" class="headerlink" title="Keyframe"></a>Keyframe</h3><p>关键帧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Keyframe ofFloat(float fraction, float value)</span><br></pre></td></tr></table></figure>

<ul>
<li>fraction：表示当前的显示进度，即从加速器中getInterpolation()函数的返回值；</li>
<li>value：表示当前应该在的位置 </li>
</ul>
<p>比如Keyframe.ofFloat(0, 0)表示动画进度为0时，动画所在的数值位置为0；Keyframe.ofFloat(0.25f, -20f)表示动画进度为25%时，动画所在的数值位置为-20；Keyframe.ofFloat(1f,0)表示动画结束时，动画所在的数值位置为0；<br>在理解了KeyFrame.ofFloat()的参数以后，我们来看看PropertyValuesHolder是如何使用KeyFrame对象的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</span><br></pre></td></tr></table></figure>

<ul>
<li>propertyName：动画所要操作的属性名</li>
<li>values：Keyframe的列表，PropertyValuesHolder会根据每个Keyframe的设定，定时将指定的值输出给动画。 </li>
</ul>
<p>完整的KeyFrame的使用代码应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Keyframe frame0 = Keyframe.ofFloat(0f, 0);</span><br><span class="line">Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);</span><br><span class="line">Keyframe frame2 = Keyframe.ofFloat(1, 0);</span><br><span class="line">PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;,frame0,frame1,frame2);</span><br><span class="line">Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage,frameHolder);</span><br><span class="line">animator.setDuration(1000);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：生成Keyframe对象；</li>
<li>第二步：利用PropertyValuesHolder.ofKeyframe()生成PropertyValuesHolder对象</li>
<li>第三步：ObjectAnimator.ofPropertyValuesHolder()生成对应的Animator</li>
</ul>
<h3 id="使用XML编写动画"><a href="#使用XML编写动画" class="headerlink" title="使用XML编写动画"></a>使用XML编写动画</h3><p>通过XML来编写动画可能会比通过代码来编写动画要慢一些，但是在重用方面将会变得非常轻松，比如某个将通用的动画编写到XML里面，我们就可以在各个界面当中轻松去重用它。</p>
<p>如果想要使用XML来编写动画，首先要在res目录下面新建一个<strong>animator文件夹</strong>，所有属性动画的XML文件都应该存放在这个文件夹当中。然后在XML文件中我们一共可以使用如下三种标签：</p>
<ul>
<li><animator>  对应代码中的ValueAnimator</li>
<li><objectAnimator>  对应代码中的ObjectAnimator</li>
<li><set>  对应代码中的AnimatorSet</li>
</ul>
<p>那么比如说我们想要实现一个从0到100平滑过渡的动画，在XML当中就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:valueFrom=&quot;0&quot;</span><br><span class="line">    android:valueTo=&quot;100&quot;</span><br><span class="line">    android:valueType=&quot;intType&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>而如果我们想将一个视图的alpha属性从1变成0，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:valueFrom=&quot;1&quot;</span><br><span class="line">    android:valueTo=&quot;0&quot;</span><br><span class="line">    android:valueType=&quot;floatType&quot;</span><br><span class="line">    android:propertyName=&quot;alpha&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>另外，我们也可以使用XML来完成复杂的组合动画操作，比如将一个视图先从屏幕外移动进屏幕，然后开始旋转360度，旋转的同时进行淡入淡出操作，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:ordering=&quot;sequentially&quot; &gt;</span><br><span class="line"> </span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:duration=&quot;2000&quot;</span><br><span class="line">        android:propertyName=&quot;translationX&quot;</span><br><span class="line">        android:valueFrom=&quot;-500&quot;</span><br><span class="line">        android:valueTo=&quot;0&quot;</span><br><span class="line">        android:valueType=&quot;floatType&quot; &gt;</span><br><span class="line">    &lt;/objectAnimator&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;set android:ordering=&quot;together&quot; &gt;</span><br><span class="line">        &lt;objectAnimator</span><br><span class="line">            android:duration=&quot;3000&quot;</span><br><span class="line">            android:propertyName=&quot;rotation&quot;</span><br><span class="line">            android:valueFrom=&quot;0&quot;</span><br><span class="line">            android:valueTo=&quot;360&quot;</span><br><span class="line">            android:valueType=&quot;floatType&quot; &gt;</span><br><span class="line">        &lt;/objectAnimator&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;set android:ordering=&quot;sequentially&quot; &gt;</span><br><span class="line">            &lt;objectAnimator</span><br><span class="line">                android:duration=&quot;1500&quot;</span><br><span class="line">                android:propertyName=&quot;alpha&quot;</span><br><span class="line">                android:valueFrom=&quot;1&quot;</span><br><span class="line">                android:valueTo=&quot;0&quot;</span><br><span class="line">                android:valueType=&quot;floatType&quot; &gt;</span><br><span class="line">            &lt;/objectAnimator&gt;</span><br><span class="line">            &lt;objectAnimator</span><br><span class="line">                android:duration=&quot;1500&quot;</span><br><span class="line">                android:propertyName=&quot;alpha&quot;</span><br><span class="line">                android:valueFrom=&quot;0&quot;</span><br><span class="line">                android:valueTo=&quot;1&quot;</span><br><span class="line">                android:valueType=&quot;floatType&quot; &gt;</span><br><span class="line">            &lt;/objectAnimator&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>

<p>XML文件是编写好了，那么我们如何在代码中把文件加载进来并将动画启动呢？只需调用如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);</span><br><span class="line">animator.setTarget(view);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p>调用<strong>AnimatorInflater</strong>的<strong>loadAnimator</strong>来将XML动画文件加载进来，然后再调用setTarget()方法将这个动画设置到某一个对象上面，最后再调用start()方法启动动画就可以了，就是这么简单。</p>
<h3 id="ValueAnimator的高级用法以及TypeEvaluator"><a href="#ValueAnimator的高级用法以及TypeEvaluator" class="headerlink" title="ValueAnimator的高级用法以及TypeEvaluator"></a>ValueAnimator的高级用法以及TypeEvaluator</h3><p>TypeEvaluator的作用到底是什么呢？简单来说，就是告诉动画系统如何从初始值过度到结束值。我们在上一篇文章中学到的ValueAnimator.ofFloat()方法就是实现了初始值与结束值之间的平滑过度，那么这个平滑过度是怎么做到的呢？其实就是系统内置了一个FloatEvaluator，它通过计算告知动画系统如何从初始值过度到结束值，我们来看一下FloatEvaluator的代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FloatEvaluator implements TypeEvaluator &#123;</span><br><span class="line">    public Object evaluate(float fraction, Object startValue, Object endValue) &#123;</span><br><span class="line">        float startFloat = ((Number) startValue).floatValue();</span><br><span class="line">        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，FloatEvaluator实现了TypeEvaluator接口，然后重写evaluate()方法。evaluate()方法当中传入了三个参数，第一个参数fraction非常重要，这个参数用于表示动画的完成度的，我们应该根据它来计算当前动画的值应该是多少，第二第三个参数分别表示动画的初始值和结束值。那么上述代码的逻辑就比较清晰了，用结束值减去初始值，算出它们之间的差值，然后乘以fraction这个系数，再加上初始值，那么就得到当前动画的值了。</p>
<p>ValueAnimator中还有一个ofObject()方法，是用于对任意对象进行动画操作的。但是相比于浮点型或整型数据，对象的动画操作明显要更复杂一些，因为系统将完全无法知道如何从初始对象过度到结束对象，因此这个时候我们就需要实现一个自己的TypeEvaluator来告知系统如何进行过度。</p>
<p>下面来先定义一个Point类，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line"> </span><br><span class="line">    private float x;</span><br><span class="line"> </span><br><span class="line">    private float y;</span><br><span class="line"> </span><br><span class="line">    public Point(float x, float y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public float getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public float getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Point类非常简单，只有x和y两个变量用于记录坐标的位置，并提供了构造方法来设置坐标，以及get方法来获取坐标。接下来定义PointEvaluator，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class PointEvaluator implements TypeEvaluator&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Object evaluate(float fraction, Object startValue, Object endValue) &#123;</span><br><span class="line">        Point startPoint = (Point) startValue;</span><br><span class="line">        Point endPoint = (Point) endValue;</span><br><span class="line">        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());</span><br><span class="line">        float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());</span><br><span class="line">        Point point = new Point(x, y);</span><br><span class="line">        return point;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，PointEvaluator同样实现了TypeEvaluator接口并重写了evaluate()方法。其实evaluate()方法中的逻辑还是非常简单的，先是将startValue和endValue强转成Point对象，然后同样根据fraction来计算当前动画的x和y的值，最后组装到一个新的Point对象当中并返回。</p>
<p>这样我们就将PointEvaluator编写完成了，接下来我们就可以非常轻松地对Point对象进行动画操作了，比如说我们有两个Point对象，现在需要将Point1通过动画平滑过度到Point2，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point point1 = new Point(0, 0);</span><br><span class="line">Point point2 = new Point(300, 300);</span><br><span class="line">ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), point1, point2);</span><br><span class="line">anim.setDuration(5000);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>

<p>好的，这就是自定义TypeEvaluator的全部用法，掌握了这些知识之后，我们就可以来尝试一下如何通过对Point对象进行动画操作，从而实现整个自定义View的动画效果。</p>
<p>新建一个MyAnimView继承自View，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MyAnimView extends View &#123;</span><br><span class="line"> </span><br><span class="line">    public static final float RADIUS = 50f;</span><br><span class="line"> </span><br><span class="line">    private Point currentPoint;</span><br><span class="line"> </span><br><span class="line">    private Paint mPaint;</span><br><span class="line"> </span><br><span class="line">    public MyAnimView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        if (currentPoint == null) &#123;</span><br><span class="line">            currentPoint = new Point(RADIUS, RADIUS);</span><br><span class="line">            drawCircle(canvas);</span><br><span class="line">            startAnimation();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            drawCircle(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void drawCircle(Canvas canvas) &#123;</span><br><span class="line">        float x = currentPoint.getX();</span><br><span class="line">        float y = currentPoint.getY();</span><br><span class="line">        canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void startAnimation() &#123;</span><br><span class="line">        Point startPoint = new Point(RADIUS, RADIUS);</span><br><span class="line">        Point endPoint = new Point(getWidth() - RADIUS, getHeight() - RADIUS);</span><br><span class="line">        ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);</span><br><span class="line">        anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">                currentPoint = (Point) animation.getAnimatedValue();</span><br><span class="line">                invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        anim.setDuration(5000);</span><br><span class="line">        anim.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在自定义View的构造方法当中初始化了一个Paint对象作为画笔，并将画笔颜色设置为蓝色，接着在onDraw()方法当中进行绘制。这里我们绘制的逻辑是由currentPoint这个对象控制的，如果currentPoint对象不等于空，那么就调用drawCircle()方法在currentPoint的坐标位置画出一个半径为50的圆，如果currentPoint对象是空，那么就调用startAnimation()方法来启动动画。</p>
<p>我们来观察一下startAnimation()方法中的代码，其实大家应该很熟悉了，就是对Point对象进行了一个动画操作而已。这里我们定义了一个startPoint和一个endPoint，坐标分别是View的左上角和右下角，并将动画的时长设为5秒。然后有一点需要大家注意的，就是我们通过监听器对动画的过程进行了监听，每当Point值有改变的时候都会回调onAnimationUpdate()方法。在这个方法当中，我们对currentPoint对象进行了重新赋值，并调用了invalidate()方法，这样的话onDraw()方法就会重新调用，并且由于currentPoint对象的坐标已经改变了，那么绘制的位置也会改变，于是一个平移的动画效果也就实现了。</p>
<p>下面我们只需要在布局文件当中引入这个自定义控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    &gt;</span><br><span class="line"> </span><br><span class="line">    &lt;com.example.tony.myapplication.MyAnimView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>

<p>最后运行一下程序，效果如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20150504225258841"></p>
<h3 id="ObjectAnimator的高级用法"><a href="#ObjectAnimator的高级用法" class="headerlink" title="ObjectAnimator的高级用法"></a>ObjectAnimator的高级用法</h3><p>我们在吐槽补间动画的时候有提到过，补间动画是只能实现移动、缩放、旋转和淡入淡出这四种动画操作的，功能限定死就是这些，基本上没有任何扩展性可言。比如我们想要实现对View的颜色进行动态改变，补间动画是没有办法做到的。</p>
<p>但是属性动画就不会受这些条条框框的限制，它的扩展性非常强，对于动态改变View的颜色这种功能是完全可是胜任的，那么下面我们就来学习一下如何实现这样的效果。</p>
<p>ObjectAnimator内部的工作机制是通过<strong>寻找特定属性的get和set方法</strong>，然后通过方法不断地对值进行改变，从而实现动画效果的。因此我们就需要在MyAnimView中定义一个color属性，并提供它的get和set方法。这里我们可以将color属性设置为字符串类型，使用#RRGGBB这种格式来表示颜色值，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyAnimView extends View &#123;</span><br><span class="line"> </span><br><span class="line">	...</span><br><span class="line"> </span><br><span class="line">	private String color;</span><br><span class="line"> </span><br><span class="line">	public String getColor() &#123;</span><br><span class="line">		return color;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public void setColor(String color) &#123;</span><br><span class="line">		this.color = color;</span><br><span class="line">		mPaint.setColor(Color.parseColor(color));</span><br><span class="line">		invalidate();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	...</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在setColor()方法当中，我们编写了一个非常简单的逻辑，就是将画笔的颜色设置成方法参数传入的颜色，然后调用了invalidate()方法。这段代码虽然只有三行，但是却执行了一个非常核心的功能，就是在改变了画笔颜色之后立即刷新视图，然后onDraw()方法就会调用。在onDraw()方法当中会根据当前画笔的颜色来进行绘制，这样颜色也就会动态进行改变了。</p>
<p>那么接下来的问题就是怎样让setColor()方法得到调用了，毫无疑问，当然是要借助ObjectAnimator类，但是在使用ObjectAnimator之前我们还要完成一个非常重要的工作，就是编写一个用于告知系统如何进行颜色过度的TypeEvaluator。创建ColorEvaluator并实现TypeEvaluator接口，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class ColorEvaluator implements TypeEvaluator &#123;</span><br><span class="line"> </span><br><span class="line">	private int mCurrentRed = -1;</span><br><span class="line"> </span><br><span class="line">	private int mCurrentGreen = -1;</span><br><span class="line"> </span><br><span class="line">	private int mCurrentBlue = -1;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public Object evaluate(float fraction, Object startValue, Object endValue) &#123;</span><br><span class="line">		String startColor = (String) startValue;</span><br><span class="line">		String endColor = (String) endValue;</span><br><span class="line">		int startRed = Integer.parseInt(startColor.substring(1, 3), 16);</span><br><span class="line">		int startGreen = Integer.parseInt(startColor.substring(3, 5), 16);</span><br><span class="line">		int startBlue = Integer.parseInt(startColor.substring(5, 7), 16);</span><br><span class="line">		int endRed = Integer.parseInt(endColor.substring(1, 3), 16);</span><br><span class="line">		int endGreen = Integer.parseInt(endColor.substring(3, 5), 16);</span><br><span class="line">		int endBlue = Integer.parseInt(endColor.substring(5, 7), 16);</span><br><span class="line">		// 初始化颜色的值</span><br><span class="line">		if (mCurrentRed == -1) &#123;</span><br><span class="line">			mCurrentRed = startRed;</span><br><span class="line">		&#125;</span><br><span class="line">		if (mCurrentGreen == -1) &#123;</span><br><span class="line">			mCurrentGreen = startGreen;</span><br><span class="line">		&#125;</span><br><span class="line">		if (mCurrentBlue == -1) &#123;</span><br><span class="line">			mCurrentBlue = startBlue;</span><br><span class="line">		&#125;</span><br><span class="line">		// 计算初始颜色和结束颜色之间的差值</span><br><span class="line">		int redDiff = Math.abs(startRed - endRed);</span><br><span class="line">		int greenDiff = Math.abs(startGreen - endGreen);</span><br><span class="line">		int blueDiff = Math.abs(startBlue - endBlue);</span><br><span class="line">		int colorDiff = redDiff + greenDiff + blueDiff;</span><br><span class="line">		if (mCurrentRed != endRed) &#123;</span><br><span class="line">			mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, 0,</span><br><span class="line">					fraction);</span><br><span class="line">		&#125; else if (mCurrentGreen != endGreen) &#123;</span><br><span class="line">			mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff,</span><br><span class="line">					redDiff, fraction);</span><br><span class="line">		&#125; else if (mCurrentBlue != endBlue) &#123;</span><br><span class="line">			mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff,</span><br><span class="line">					redDiff + greenDiff, fraction);</span><br><span class="line">		&#125;</span><br><span class="line">		// 将计算出的当前颜色的值组装返回</span><br><span class="line">		String currentColor = &quot;#&quot; + getHexString(mCurrentRed)</span><br><span class="line">				+ getHexString(mCurrentGreen) + getHexString(mCurrentBlue);</span><br><span class="line">		return currentColor;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * 根据fraction值来计算当前的颜色。</span><br><span class="line">	 */</span><br><span class="line">	private int getCurrentColor(int startColor, int endColor, int colorDiff,</span><br><span class="line">			int offset, float fraction) &#123;</span><br><span class="line">		int currentColor;</span><br><span class="line">		if (startColor &gt; endColor) &#123;</span><br><span class="line">			currentColor = (int) (startColor - (fraction * colorDiff - offset));</span><br><span class="line">			if (currentColor &lt; endColor) &#123;</span><br><span class="line">				currentColor = endColor;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			currentColor = (int) (startColor + (fraction * colorDiff - offset));</span><br><span class="line">			if (currentColor &gt; endColor) &#123;</span><br><span class="line">				currentColor = endColor;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return currentColor;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 将10进制颜色值转换成16进制。</span><br><span class="line">	 */</span><br><span class="line">	private String getHexString(int value) &#123;</span><br><span class="line">		String hexString = Integer.toHexString(value);</span><br><span class="line">		if (hexString.length() == 1) &#123;</span><br><span class="line">			hexString = &quot;0&quot; + hexString;</span><br><span class="line">		&#125;</span><br><span class="line">		return hexString;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在evaluate()方法当中获取到颜色的初始值和结束值，并通过字符串截取的方式将颜色分为RGB三个部分，并将RGB的值转换成十进制数字，那么每个颜色的取值范围就是0-255。接下来计算一下初始颜色值到结束颜色值之间的差值，这个差值很重要，决定着颜色变化的快慢，如果初始颜色值和结束颜色值很相近，那么颜色变化就会比较缓慢，而如果颜色值相差很大，比如说从黑到白，那么就要经历255*3这个幅度的颜色过度，变化就会非常快。</p>
<p>那么控制颜色变化的速度是通过getCurrentColor()这个方法来实现的，这个方法会根据当前的fraction值来计算目前应该过度到什么颜色，并且这里会根据初始和结束的颜色差值来控制变化速度，最终将计算出的颜色进行返回。</p>
<p>最后，由于我们计算出的颜色是十进制数字，这里还需要调用一下getHexString()方法把它们转换成十六进制字符串，再将RGB颜色拼装起来之后作为最终的结果返回。</p>
<p>好了，ColorEvaluator写完之后我们就把最复杂的工作完成了，剩下的就是一些简单调用的问题了，比如说我们想要实现从蓝色到红色的动画过度，历时5秒，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator.ofObject(myAnimView, &quot;color&quot;, new ColorEvaluator(), </span><br><span class="line">	&quot;#0000FF&quot;, &quot;#FF0000&quot;);</span><br><span class="line">anim.setDuration(5000);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>

<p>接下来我们需要将上面一段代码移到MyAnimView类当中，让它和刚才的Point移动动画可以结合到一起播放，这就要借助我们刚才学到的组合动画的技术了。修改MyAnimView中的代码，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyAnimView extends View &#123;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    private void startAnimation() &#123;</span><br><span class="line">        Point startPoint = new Point(RADIUS, RADIUS);</span><br><span class="line">        Point endPoint = new Point(getWidth() - RADIUS, getHeight() - RADIUS);</span><br><span class="line">        ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);</span><br><span class="line">        anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">                currentPoint = (Point) animation.getAnimatedValue();</span><br><span class="line">                invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ObjectAnimator anim2 = ObjectAnimator.ofObject(this, &quot;color&quot;, new ColorEvaluator(), </span><br><span class="line">        		&quot;#0000FF&quot;, &quot;#FF0000&quot;);</span><br><span class="line">        AnimatorSet animSet = new AnimatorSet();</span><br><span class="line">        animSet.play(anim).with(anim2);</span><br><span class="line">        animSet.setDuration(5000);</span><br><span class="line">        animSet.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在重新运行一下代码，效果如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20150504225554203"></p>
<h3 id="Interpolator的用法"><a href="#Interpolator的用法" class="headerlink" title="Interpolator的用法"></a>Interpolator的用法</h3><p>Interpolator：<strong>差值器</strong>。它的主要作用是可以<strong>控制动画的变化速率</strong>，比如去实现一种非线性运动的动画效果。那么什么叫做非线性运动的动画效果呢？就是说动画改变的速率不是一成不变的，像加速运动以及减速运动都属于非线性运动。</p>
<p>Interpolator并不是属性动画中新增的技术，实际上从Android 1.0版本开始就一直存在Interpolator接口了，而之前的补间动画当然也是支持这个功能的。只不过在属性动画中新增了一个<strong>TimeInterpolator</strong>接口，这个接口是用于兼容之前的Interpolator的，这使得所有过去的Interpolator实现类都可以直接拿过来放到属性动画当中使用，那么我们来看一下现在TimeInterpolator接口的所有实现类，如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20150524114950506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>TimeInterpolator接口已经有非常多的实现类了，这些都是Android系统内置好的并且我们可以直接使用的Interpolator。每个Interpolator都有它各自的实现效果，比如说AccelerateInterpolator就是一个加速运动的Interpolator，而DecelerateInterpolator就是一个减速运动的Interpolator。</p>
<table>
<thead>
<tr>
<th>Java类</th>
<th>资源ID</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>AccelerateInterpolator</td>
<td>@android:anim/accelerate_interpolator</td>
<td>加速进行</td>
</tr>
<tr>
<td>DecelerateInterpolator</td>
<td>@android:anim/decelerate_interpolator</td>
<td>减速进行</td>
</tr>
<tr>
<td>LinearInterpolator</td>
<td>@android:anim/linear_interpolator</td>
<td>匀速进行</td>
</tr>
<tr>
<td>AccelerateDecelerateInterpolator</td>
<td>@android:anim/accelerate_decelerate_interpolator</td>
<td>先加速再减速</td>
</tr>
<tr>
<td>OvershootInterpolator</td>
<td>@android:anim/overshoot_interpolator</td>
<td>快速完成动画，超出再回到结束样式</td>
</tr>
<tr>
<td>AnticipateInterpolator</td>
<td>@android:anim/anticipate_interpolator</td>
<td>先退后再加速前进</td>
</tr>
<tr>
<td>AnticipateOvershootInterpolator</td>
<td>@android:anim/anticipate_overshoot_interpolator</td>
<td>先退后再加速前进，超出终点后再回终点</td>
</tr>
<tr>
<td>BounceInterpolator</td>
<td>@android:anim/bounce_interpolator</td>
<td>最后阶段弹球效果</td>
</tr>
<tr>
<td>CycleInterpolator</td>
<td>@android:anim/cycle_interpolator</td>
<td>周期运动</td>
</tr>
</tbody></table>
<p>使用属性动画时，系统默认的Interpolator其实就是一个先加速后减速的Interpolator，对应的实现类就是<strong>AccelerateDecelerateInterpolator</strong>。</p>
<p>当然，我们也可以很轻松地修改这一默认属性，将它替换成任意一个系统内置好的Interpolator。以上边的代码来举例，MyAnimView中的startAnimation()方法是开启动画效果的入口，这里我们对Point对象的坐标稍做一下修改，让它变成一种垂直掉落的效果，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void startAnimation() &#123;</span><br><span class="line">    Point startPoint = new Point(getWidth() / 2, RADIUS);</span><br><span class="line">    Point endPoint = new Point(getWidth() / 2, getHeight() - RADIUS);</span><br><span class="line">    ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);</span><br><span class="line">    anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">            currentPoint = (Point) animation.getAnimatedValue();</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    anim.setDuration(2000);</span><br><span class="line">    anim.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是对Point构造函数中的坐标值进行了一下改动，那么现在小球运动的动画效果应该是从屏幕正中央的顶部掉落到底部。但是现在默认情况下小球的下降速度肯定是先加速后减速的，这不符合物理的常识规律，如果把小球视为一个自由落体的话，那么下降的速度应该是越来越快的。我们怎样才能改变这一默认行为呢？其实很简单，调用Animator的setInterpolator()方法就可以了，这个方法要求传入一个实现TimeInterpolator接口的实例，那么比如说我们想要实现小球下降越来越快的效果，就可以使用AccelerateInterpolator，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void startAnimation() &#123;</span><br><span class="line">    Point startPoint = new Point(getWidth() / 2, RADIUS);</span><br><span class="line">    Point endPoint = new Point(getWidth() / 2, getHeight() - RADIUS);</span><br><span class="line">    ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);</span><br><span class="line">    anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">            currentPoint = (Point) animation.getAnimatedValue();</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    anim.setInterpolator(new AccelerateInterpolator(2f));</span><br><span class="line">    anim.setDuration(2500);</span><br><span class="line">    anim.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，这里调用了setInterpolator()方法，然后传入了一个AccelerateInterpolator的实例，注意AccelerateInterpolator的构建函数可以接收一个float类型的参数，这个参数是用于控制加速度的。现在运行一下代码，效果如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20150530224918252"></p>
<p>效果非常明显，说明我们已经成功替换掉了默认的Interpolator，AccelerateInterpolator确实是生效了。但是现在的动画效果看上去仍然是怪怪的，因为一个小球从很高的地方掉落到地面上直接就静止了，这也是不符合物理规律的，小球撞击到地面之后应该要反弹起来，然后再次落下，接着再反弹起来，又再次落下，以此反复，最后静止。这个功能我们当然可以自己去写，只不过比较复杂，所幸的是，Android系统中已经提供好了这样一种Interpolator，我们只需要简单地替换一下就可以完成上面的描述的效果，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void startAnimation() &#123;</span><br><span class="line">    Point startPoint = new Point(getWidth() / 2, RADIUS);</span><br><span class="line">    Point endPoint = new Point(getWidth() / 2, getHeight() - RADIUS);</span><br><span class="line">    ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);</span><br><span class="line">    anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">            currentPoint = (Point) animation.getAnimatedValue();</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    anim.setInterpolator(new BounceInterpolator());</span><br><span class="line">    anim.setDuration(3000);</span><br><span class="line">    anim.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只是将设置的Interpolator换成了BounceInterpolator的实例，而BounceInterpolator就是一种可以模拟物理规律，实现反复弹起效果的Interpolator。另外还将整体的动画时间稍微延长了一点，因为小球反复弹起需要比之前更长的时间。现在重新运行一下代码，效果如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20150530230521897"></p>
<p>下面我们就来看一下Interpolator的内部实现机制是什么样的，并且来尝试写一个自定义的Interpolator。</p>
<p>首先看一下TimeInterpolator的接口定义，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A time interpolator defines the rate of change of an animation. This allows animations</span><br><span class="line"> * to have non-linear motion, such as acceleration and deceleration.</span><br><span class="line"> */</span><br><span class="line">public interface TimeInterpolator &#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Maps a value representing the elapsed fraction of an animation to a value that represents</span><br><span class="line">     * the interpolated fraction. This interpolated value is then multiplied by the change in</span><br><span class="line">     * value of an animation to derive the animated value at the current elapsed animation time.</span><br><span class="line">     *</span><br><span class="line">     * @param input A value between 0 and 1.0 indicating our current point</span><br><span class="line">     *        in the animation where 0 represents the start and 1.0 represents</span><br><span class="line">     *        the end</span><br><span class="line">     * @return The interpolation value. This value can be more than 1.0 for</span><br><span class="line">     *         interpolators which overshoot their targets, or less than 0 for</span><br><span class="line">     *         interpolators that undershoot their targets.</span><br><span class="line">     */</span><br><span class="line">    float getInterpolation(float input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口还是非常简单的，只有一个getInterpolation()方法。大家有兴趣可以通过注释来对这个接口进行详解的了解，这里我就简单解释一下，getInterpolation()方法中接收一个input参数，这个参数的值会随着动画的运行而不断变化，不过它的变化是非常有规律的，就是根据设定的动画时长匀速增加，变化范围是0到1。也就是说当动画一开始的时候input的值是0，到动画结束的时候input的值是1，而中间的值则是随着动画运行的时长在0到1之间变化的。</p>
<p>说到这个input的值，我觉得有不少朋友可能会联想到我们上边使用过的fraction值。那么这里的input和fraction有什么关系或者区别呢？答案很简单，input的值决定了fraction的值。input的值是由系统经过计算后传入到getInterpolation()方法中的，然后我们可以自己实现getInterpolation()方法中的算法，根据input的值来计算出一个返回值，而这个返回值就是fraction了。</p>
<p>因此，最简单的情况就是input值和fraction值是相同的，这种情况由于input值是匀速增加的，因而fraction的值也是匀速增加的，所以动画的运动情况也是匀速的。系统中内置的LinearInterpolator就是一种匀速运动的Interpolator，那么我们来看一下它的源码是怎么实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An interpolator where the rate of change is constant</span><br><span class="line"> */</span><br><span class="line">@HasNativeInterpolator</span><br><span class="line">public class LinearInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123;</span><br><span class="line"> </span><br><span class="line">    public LinearInterpolator() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public LinearInterpolator(Context context, AttributeSet attrs) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public float getInterpolation(float input) &#123;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /** @hide */</span><br><span class="line">    @Override</span><br><span class="line">    public long createNativeInterpolator() &#123;</span><br><span class="line">        return NativeInterpolatorFactoryHelper.createLinearInterpolator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们只看getInterpolation()方法，这个方法没有任何逻辑，就是把参数中传递的input值直接返回了，因此fraction的值就是等于input的值的，这就是匀速运动的Interpolator的实现方式。</p>
<p>编写自定义Interpolator最主要的难度都是在于数学计算方面的，由于我数学并不是很好，因此这里也就写一个简单点的Interpolator来给大家演示一下。既然属性动画默认的Interpolator是先加速后减速的一种方式，这里我们就对它进行一个简单的修改，让它变成先减速后加速的方式。新建DecelerateAccelerateInterpolator类，让它实现TimeInterpolator接口，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DecelerateAccelerateInterpolator implements TimeInterpolator&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public float getInterpolation(float input) &#123;</span><br><span class="line">        float result;</span><br><span class="line">        if (input &lt;= 0.5) &#123;</span><br><span class="line">            result = (float) (Math.sin(Math.PI * input)) / 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = (float) (2 - Math.sin(Math.PI * input)) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是使用正弦函数来实现先减速后加速的功能的，因为正弦函数初始弧度的变化值非常大，刚好和余弦函数是相反的，而随着弧度的增加，正弦函数的变化值也会逐渐变小，这样也就实现了减速的效果。当弧度大于π/2之后，整个过程相反了过来，现在正弦函数的弧度变化值非常小，渐渐随着弧度继续增加，变化值越来越大，弧度到π时结束，这样从0过度到π，也就实现了先减速后加速的效果。</p>
<p>我们可以将这个算法的执行情况通过曲线图的方式绘制出来，结果如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20150530221803332?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<h3 id="ViewPropertyAnimator的用法"><a href="#ViewPropertyAnimator的用法" class="headerlink" title="ViewPropertyAnimator的用法"></a>ViewPropertyAnimator的用法</h3><p>我们知道，属性动画的机制已经不是再针对于View而进行设计的了，而是一种不断地对值进行操作的机制，它可以将值赋值到指定对象的指定属性上。但是，在绝大多数情况下，大家主要都还是对View进行动画操作的。Android开发团队也是意识到了这一点，没有为View的动画操作提供一种更加便捷的用法确实是有点太不人性化了，于是在Android 3.1系统当中补充了ViewPropertyAnimator这个机制。</p>
<p>ViewPropertyAnimator提供了更加易懂、更加面向对象的API，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textview.animate().alpha(0f);</span><br></pre></td></tr></table></figure>

<p>textview.animate()这个方法是怎么回事呢？animate()方法就是在Android 3.1系统上新增的一个方法，这个方法的返回值是一个ViewPropertyAnimator对象，也就是说拿到这个对象之后我们就可以调用它的各种方法来实现动画效果了，这里我们调用了alpha()方法并转入0，表示将当前的textview变成透明状态。</p>
<p>比起使用ObjectAnimator，ViewPropertyAnimator的用法明显更加简单易懂吧。除此之外，ViewPropertyAnimator还可以很轻松地将多个动画组合到一起，比如我们想要让textview运动到500,500这个坐标点上，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textview.animate().x(500).y(500);</span><br></pre></td></tr></table></figure>

<p>那么怎样去设定动画的运行时长呢？很简单，也是通过连缀的方式设定即可，比如我们想要让动画运行5秒钟，就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textview.animate().x(500).y(500).setDuration(5000);</span><br></pre></td></tr></table></figure>

<p>关于ViewPropertyAnimator有几个细节还是值得大家注意一下的：</p>
<ul>
<li>整个ViewPropertyAnimator的功能都是建立在View类新增的animate()方法之上的，这个方法会创建并返回一个ViewPropertyAnimator的实例，之后的调用的所有方法，设置的所有属性都是通过这个实例完成的。</li>
<li>在使用ViewPropertyAnimator时，我们自始至终没有调用过start()方法，这是因为新的接口中使用了隐式启动动画的功能，只要我们将动画定义完成之后，动画就会自动启动。并且这个机制对于组合动画也同样有效，只要我们不断地连缀新的方法，那么动画就不会立刻执行，等到所有在ViewPropertyAnimator上设置的方法都执行完毕后，动画就会自动启动。当然如果不想使用这一默认机制的话，我们也可以显式地调用start()方法来启动动画。</li>
</ul>
<h2 id="转场动画-amp-过渡动画"><a href="#转场动画-amp-过渡动画" class="headerlink" title="转场动画&amp;过渡动画"></a>转场动画&amp;过渡动画</h2><p>过渡动画是Android 5.0 以后提供同的一套动画框架，那么什么是过渡动画呢？借助官网的解释：使用 <strong>过渡</strong> 为 <strong>布局变化</strong> 添加 <strong>动画效果</strong>。</p>
<p>Trasition 内部保存了所有关于动画的信息，当场景变换时动画将在目标对象上执行。Transition基于两个概念：场景（scenes）和变换（transitions），场景是UI当前状态，变换则定义了在不同场景之间动画变化的过程。</p>
<p>Transition分为三种类型（android5.0中使用）:</p>
<ul>
<li>进入动画：Activity中的所有视图进入屏幕的动画</li>
<li>退出动画：Activity中的所有视图退出屏幕的动画</li>
<li>共享元素动画：利用共享的元素实现Activity的跳转动画</li>
</ul>
<p>进入动画和退出动画合称Content Transition（内容变换动画），所以Transition分为<strong>内容变换动画</strong>和<strong>共享元素动画</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29ff6a272da0475f80c0ef52fd1e5688~tplv-k3u1fbpfcp-zoom-1.image"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TransitionSet</td>
<td>组合效果</td>
</tr>
<tr>
<td>AutoTransition</td>
<td>默认过渡动画，fade out 渐隐， move 位移 和 resize 大小缩放，fade in 渐显 ，按顺序</td>
</tr>
<tr>
<td>ChangeBounds</td>
<td>检测view的位置边界创建移动和缩放动画</td>
</tr>
<tr>
<td>ChangeClipBounds</td>
<td>检测view的剪切区域的位置边界，和ChangeBounds类似。不过ChangeBounds针对的是view而ChangeClipBounds针对的是view的剪切区域(setClipBound(Rect rect) 中的rect)。如果没有设置则没有动画效果</td>
</tr>
<tr>
<td>ChangeImageTransform</td>
<td>检测ImageView（这里是专指ImageView）的尺寸，位置以及ScaleType，并创建相应动画 一般时候，我们都是和 ChangeBounds 一起使用，能够做出很漂亮的动画</td>
</tr>
<tr>
<td>ChangeTransform</td>
<td>检测view的scale和rotation创建缩放和旋转动画</td>
</tr>
<tr>
<td>ChangeScroll</td>
<td>改变滑动位置</td>
</tr>
<tr>
<td>Explode</td>
<td>分解</td>
</tr>
<tr>
<td>Fade</td>
<td>淡入淡出 有 fade_in,fade_out,fade_in_out</td>
</tr>
<tr>
<td>Slide</td>
<td>从哪边滑动出，有 left, top, right, bottom, start, end 模式</td>
</tr>
</tbody></table>
<p>核心关键类 <a target="_blank" rel="noopener" href="https://www.apiref.com/android-zh/android/transition/TransitionManager.html"><strong>TransitionManager</strong></a>, TransitionManager.beginDelayedTransition(ViewGroup viewGroup, Transition transition); 作为动画的开始，传入需要做转场动画的父布局或根布局，随后改变 View 的相关属性，比如 setVisible()，便可自动完成转场动画效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4648b2661b249528709ca52e13d537f~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>默认实现的 <strong>AutoTransition</strong>，内部集成了基础动画：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void init() &#123;</span><br><span class="line">    setOrdering(ORDERING_SEQUENTIAL);</span><br><span class="line">    addTransition(new Fade(Fade.OUT)).</span><br><span class="line">            addTransition(new ChangeBounds()).</span><br><span class="line">            addTransition(new Fade(Fade.IN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Slide、Fade-和-Explode"><a href="#Slide、Fade-和-Explode" class="headerlink" title="Slide、Fade 和 Explode"></a>Slide、Fade 和 Explode</h3><p>这三者作为 Visibility 的三个子类，通过控制 <strong>view.setVisible()</strong> 的方式来达到具体的效果。</p>
<p>Fade，淡出 出场，淡入 入场</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fedb5ec3f373401fa1897938c4ea2c5b~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>Slide，向下离开屏幕出场，向上进入屏幕入场</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/356081375df841399c5e09699cf906eb~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>Explode，四边散开出场，四边汇入入场</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85007fba17042f18600ef65cda98341~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>同样，可以通过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fade fade = new Fade();</span><br><span class="line">Slide slide = new Slide();</span><br><span class="line">TransitionSet set = new TransitionSet();</span><br><span class="line">set.addTransition(fade).addTransition(slide).setOrdering(TransitionSet.ORDERING_TOGETHER);</span><br></pre></td></tr></table></figure>

<p>达到组合的效果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20657740010043caa63cf037c35a1875~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="ChangeBounds"><a href="#ChangeBounds" class="headerlink" title="ChangeBounds"></a>ChangeBounds</h3><p>ChangeBounds 当 View 的位置或者大小发生变化时触发对应的转场效果。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChangeBounds transition = new ChangeBounds();</span><br><span class="line">transition.setInterpolator(new AnticipateInterpolator());</span><br><span class="line">TransitionManager.beginDelayedTransition(mRoot, transition);</span><br><span class="line">ConstraintLayout.LayoutParams layoutParams = (ConstraintLayout.LayoutParams) view3.getLayoutParams();</span><br><span class="line">if (layoutParams.leftMargin == 400) &#123;</span><br><span class="line">    layoutParams.leftMargin = 50;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    layoutParams.leftMargin = 400;</span><br><span class="line">&#125;</span><br><span class="line">view3.setLayoutParams(layoutParams);</span><br></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8941bcdf9f2f4cb0a13fe0caa43c80a2~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="ChangeClipBounds"><a href="#ChangeClipBounds" class="headerlink" title="ChangeClipBounds"></a>ChangeClipBounds</h3><p>当调用 view.setClipBounds() 时会触发转场效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ChangeClipBounds transition = new ChangeClipBounds();</span><br><span class="line">transition.setInterpolator(new BounceInterpolator());</span><br><span class="line">TransitionManager.beginDelayedTransition(mRoot, transition);</span><br><span class="line">int width = view2.getWidth();</span><br><span class="line">int height = view2.getHeight();</span><br><span class="line">int gap = 140;</span><br><span class="line">Rect rect = new Rect(0, gap, width, height - gap);</span><br><span class="line">if (rect.equals(view2.getClipBounds())) &#123;</span><br><span class="line">    view2.setClipBounds(null);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    view2.setClipBounds(rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0666b61f2db54ca8924178c37523010c~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="ChangeScroll"><a href="#ChangeScroll" class="headerlink" title="ChangeScroll"></a>ChangeScroll</h3><p>当调用 view.scrollTo() 会触发转场效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ChangeScroll transition = new ChangeScroll();</span><br><span class="line">transition.setInterpolator(new AnticipateOvershootInterpolator());</span><br><span class="line">TransitionManager.beginDelayedTransition(mRoot, transition);</span><br><span class="line">if (view1.getScrollX() == -100 &amp;&amp; view1.getScrollY() == -100) &#123;</span><br><span class="line">    view1.scrollTo(0, 0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    view1.scrollTo(-100, -100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6d2910ebdde421c95ef1df93dc19bf1~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="ChangeTransform"><a href="#ChangeTransform" class="headerlink" title="ChangeTransform"></a>ChangeTransform</h3><p>这个就厉害了，View 的 translation、scale 和 rotation 发生改变时都会触发：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ChangeTransform transition = new ChangeTransform();</span><br><span class="line">transition.setInterpolator(new OvershootInterpolator());</span><br><span class="line">TransitionManager.beginDelayedTransition(mRoot, transition);</span><br><span class="line">if (view1.getTranslationX() == 100 &amp;&amp; view1.getTranslationY() == 100) &#123;</span><br><span class="line">    view1.setTranslationX(0);</span><br><span class="line">    view1.setTranslationY(0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    view1.setTranslationX(100);</span><br><span class="line">    view1.setTranslationY(100);</span><br><span class="line">&#125;</span><br><span class="line">if (view2.getRotationX() == 30f) &#123;</span><br><span class="line">    view2.setRotationX(0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    view2.setRotationX(30);</span><br><span class="line">&#125;</span><br><span class="line">if (view3.getRotationY() == 30f) &#123;</span><br><span class="line">    view3.setRotationY(0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    view3.setRotationY(30);</span><br><span class="line">&#125;</span><br><span class="line">if (view4.getScaleX() == 0.5f &amp;&amp; view4.getScaleY() == 0.5f) &#123;</span><br><span class="line">    view4.setScaleX(1f);</span><br><span class="line">    view4.setScaleY(1f);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    view4.setScaleX(0.5f);</span><br><span class="line">    view4.setScaleY(0.5f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/697dc92b19ad4b3f892a6ed7edf5a546~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="使用场景动画做转场"><a href="#使用场景动画做转场" class="headerlink" title="使用场景动画做转场"></a>使用场景动画做转场</h3><p>在使用 Transition 的 activity 中需要启用 transition ，可以通过代码也可以通过设置主题：</p>
<p>代码方式，在<strong>setContentView之前调用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    // 启用窗口内容过渡 要在 setContentView 之前设置</span><br><span class="line">    window.requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)</span><br><span class="line">    setContentView(R.layout.activity_first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主题xml方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;BaseAppTheme&quot; parent=&quot;android:Theme.Material&quot;&gt;</span><br><span class="line">  &lt;!-- enable window content transitions --&gt;</span><br><span class="line">  &lt;item name=&quot;android:windowActivityTransitions&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>Fragment中使用Transition，和activity中使用大体相同，不同点如下：</p>
<ul>
<li>Fragment在其FragmentTransaction执行added, removed, attached, detached, shown，hidden时触发动画</li>
<li>在Fragment commit之前，共享元素需要通过调用addSharedElement(View, String) 方法来成为FragmentTransaction的一部分</li>
</ul>
<p>Activity/Fragment 转场时候，界面其实是可以分成4个动画：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/361dd8d8a473441c8a530f3be795554d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17e69f7676954953927be43c223d5631~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>对应的方法为：</p>
<ul>
<li>Window.setEnterTransition()</li>
<li>Window.setExitTransition()</li>
<li>Window.setReenterTransition()</li>
<li>Window.setReturnTransition()</li>
</ul>
<h4 id="Content-Transition"><a href="#Content-Transition" class="headerlink" title="Content Transition"></a>Content Transition</h4><p>Content transition决定了非共享view元素在activity和fragment切换期间是如何进入或者退出场景的，可以利用代码或者XML方式实现。</p>
<blockquote>
<p>设置Content Transition的函数：</p>
<p>setEnterTransition() - ActivityA 跳转到 ActivityB，ActivityB中的View进入场景的transition。</p>
<p>setExitTransition() - ActivityA 跳转到 ActivityB，ActivityA中的View退出场景的transition。</p>
<p>setReturnTransition() - 从ActivityB 返回Activity A时，ActivityB中的View退出场景的transition。</p>
<p>setReenterTransition() - 从ActivityB 返回Activity A时，ActivityA中的View进入场景的transition</p>
</blockquote>
<p>xml中的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//对应setEnterTransition</span><br><span class="line">&lt;item name=&quot;android:windowEnterTransition&quot;&gt;&lt;/item&gt;   </span><br><span class="line">//对应setExitTransition</span><br><span class="line">&lt;item name=&quot;android:windowExitTransition&quot;&gt;&lt;/item&gt;</span><br><span class="line">//对应setReturnTransition</span><br><span class="line">&lt;item name=&quot;android:windowReturnTransition&quot;&gt;&lt;/item&gt;</span><br><span class="line">//对应setReenterTransition</span><br><span class="line">&lt;item name=&quot;android:windowReenterTransition&quot;&gt;&lt;/item&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>系统提供的动画效果（用于content Transition）</p>
<p>explode(分解)：从屏幕中间进或出，移动视图。</p>
<p>slide(滑动)：从屏幕边缘进或出，移动试图。</p>
<p>fade(淡出)：通过改变屏幕上的视图的不透明度，达到添加或移除视图。</p>
</blockquote>
<p>三种效果都有对应的实现类，分别为：</p>
<p>分解：Explode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">&lt;explode</span><br><span class="line">    android:duration=&quot;500&quot;</span><br><span class="line">    android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;/&gt;</span><br><span class="line">&lt;/transitionSet&gt;</span><br></pre></td></tr></table></figure>

<p>滑动：Slide，setSlideEdge(int slideEdge) 设置从哪个边出现或隐藏，取值为<br>Gravity.LEFT, Gravity.TOP, Gravity.RIGHT, Gravity.BOTTOM, Gravity.START, Gravity.END。对应的xml中的属性为android:slideEdge</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;slide</span><br><span class="line">        android:duration=&quot;500&quot;</span><br><span class="line">        android:slideEdge=&quot;bottom&quot;</span><br><span class="line">        android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; /&gt;</span><br><span class="line">&lt;/transitionSet&gt;</span><br></pre></td></tr></table></figure>

<p>淡入淡出：Fade</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">&lt;fade</span><br><span class="line">    android:duration=&quot;500&quot;</span><br><span class="line">    android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot;/&gt;</span><br><span class="line">&lt;/transitionSet&gt;</span><br></pre></td></tr></table></figure>

<h4 id="xml中实现进入退出动画"><a href="#xml中实现进入退出动画" class="headerlink" title="xml中实现进入退出动画"></a>xml中实现进入退出动画</h4><p>Style中设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowEnterTransition&quot;&gt;@transition/explode&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/fade&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowReenterTransition&quot;&gt;@transition/solid&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowReturnTransition&quot;&gt;@transition/explode&lt;/item&gt;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptionsCompat activityOptionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation(Main8Activity.this);</span><br><span class="line">Intent intent = new Intent(Main8Activity.this, Main7Activity.class);</span><br><span class="line">startActivity(intent,activityOptionsCompat.toBundle());</span><br></pre></td></tr></table></figure>

<p>退出时调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBackPressed() &#123;</span><br><span class="line">    super.onBackPressed();</span><br><span class="line">    ActivityCompat.finishAfterTransition(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>开始一个activity的content transition需要调用startActivity(Context, Bundle)方法，Bundle参数生成方法<strong>ActivityOptions.makeSceneTransitionAnimation(activity, pairs).toBundle()</strong></p>
<p>在代码中触发通过**finishAfterTransition()**方法触发返回动画，而不是调用finish()方法</p>
</blockquote>
<h4 id="代码方式实现"><a href="#代码方式实现" class="headerlink" title="代码方式实现"></a>代码方式实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</span><br><span class="line">    getWindow().setEnterTransition(new Explode());</span><br><span class="line">    getWindow().setExitTransition(new Fade());</span><br><span class="line">    Transition transition1 =  TransitionInflater.from(Main8Activity.this).inflateTransition(android.R.transition.slide_bottom);</span><br><span class="line">    getWindow().setReenterTransition(transition1);</span><br><span class="line">    Transition transition2 =  TransitionInflater.from(Main8Activity.this).inflateTransition(R.transition.explode);</span><br><span class="line">    getWindow().setReturnTransition(transition2);</span><br><span class="line">    //super.onCreate之前</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br></pre></td></tr></table></figure>

<p>如果从ActivityA启动ActivityB，界面切换的时候，ActivityA退出还没有完全展示退出动画时，ActivityB就进入了，如果想等ActivityA完全退出后ActivityB再进入，可以通过设置<strong>setAllowEnterTransitionOverlap(false)</strong>(默认是true)，同样可以在xml中设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowAllowEnterTransitionOverlap&quot;&gt;false&lt;/item&gt;</span><br><span class="line">&lt;item name=&quot;android:windowAllowReturnTransitionOverlap&quot;&gt;false&lt;/item&gt;</span><br></pre></td></tr></table></figure>

<h3 id="共享元素动画"><a href="#共享元素动画" class="headerlink" title="共享元素动画"></a>共享元素动画</h3><blockquote>
<p>共享元素动画需要对共享的元素上添加 <strong>android:transitionName</strong> 来设置transitionName ，它的值随意，但两个共享的元素这个值要保持一致。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ActivityA</span><br><span class="line">&lt;ImageView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:src=&quot;@drawable/hongbao&quot;</span><br><span class="line">    android:transitionName=&quot;shareElement&quot;/&gt;</span><br><span class="line">ActivityB</span><br><span class="line">&lt;ImageView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:src=&quot;@drawable/hongbao&quot;</span><br><span class="line">    android:transitionName=&quot;shareElement&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>利用startActivity(Intent intent, Bundle options) 启动Activity：</p>
<p>利用ActivityOptionsCompat的<strong>makeSceneTransitionAnimation</strong>函数生成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = ActivityOptionsCompat.makeSceneTransitionAnimation(MainActivity.this,view,&quot;shareElement&quot;).toBundle();</span><br><span class="line">Intent intent = new Intent(MainActivity.this, MainActivity2.class);</span><br><span class="line">startActivity(intent,bundle);</span><br></pre></td></tr></table></figure>

<p>共享多个元素：</p>
<p>makeSceneTransitionAnimation函数还有一个重载函数，传入多个<strong>Pair对象</strong>。</p>
<p>ActivityOptionsCompat makeSceneTransitionAnimation(@NonNull Activity activity, Pair… sharedElements)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pair pair1 = new Pair(gongxiang,&quot;shareElement&quot;);</span><br><span class="line">Pair pair2 = new Pair(gongxiang2,&quot;shareElement2&quot;);</span><br><span class="line">Bundle bundle = ActivityOptionsCompat.makeSceneTransitionAnimation(Main8Activity.this,pair1,pair2).toBundle();</span><br><span class="line">Intent intent = new Intent(Main8Activity.this, Main7Activity.class);</span><br><span class="line">startActivity(intent,bundle);</span><br></pre></td></tr></table></figure>

<p>封装类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 转场动画</span><br><span class="line">     *</span><br><span class="line">     * @param context           activity</span><br><span class="line">     * @param intent            intent</span><br><span class="line">     * @param sharedElement     共享view</span><br><span class="line">     * @param sharedElementName 共享view的name,和目标activity的目标view要有相同的sharedElementName</span><br><span class="line">     */</span><br><span class="line">    public static void makeSceneTransitionAnimation(Context context, Intent intent,</span><br><span class="line">                                                    View sharedElement, String sharedElementName) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            sharedElement.setTransitionName(sharedElementName);</span><br><span class="line">            ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation((Activity) context,</span><br><span class="line">                    sharedElement, sharedElementName);</span><br><span class="line">            ActivityCompat.startActivity(context, intent, options.toBundle());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            context.startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转场动画</span><br><span class="line">     *</span><br><span class="line">     * @param context        activity</span><br><span class="line">     * @param intent         intent</span><br><span class="line">     * @param sharedElements 共享view集</span><br><span class="line">     */</span><br><span class="line">    public static void makeSceneTransitionAnimationPair(Context context, Intent intent,</span><br><span class="line">                                                        Pair&lt;View, String&gt;... sharedElements) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(</span><br><span class="line">                    (Activity) context, sharedElements);</span><br><span class="line">            ActivityCompat.startActivity(context, intent, options.toBundle());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            context.startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void launchActivity(@NonNull Context context, View view) &#123;</span><br><span class="line">        Intent intent = new Intent(context, UserSignActivity.class);</span><br><span class="line">        Utils.makeSceneTransitionAnimation(context, intent, view, context.getString(R.string.transition_mine_img));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-0-以前设置转场动画"><a href="#5-0-以前设置转场动画" class="headerlink" title="5.0 以前设置转场动画"></a>5.0 以前设置转场动画</h3><p>使用 <strong>overridePendingTransition</strong> 实现转场动画。</p>
<p>入场设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startActivity(intent)</span><br><span class="line">//参数1 进场动画 （B Activity 出现的动画）</span><br><span class="line">//参数2 退场动画 （A Activity 消失的动画）</span><br><span class="line">overridePendingTransition(R.anim.enter_in, R.anim.enter_out)</span><br></pre></td></tr></table></figure>

<p>退场设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finish()</span><br><span class="line">//参数1 进场动画 （A Activity 出现的动画）</span><br><span class="line">//参数2 退场动画 （B Activity 消失的动画）</span><br><span class="line">overridePendingTransition(R.anim.exit_in, R.anim.exit_out)</span><br></pre></td></tr></table></figure>

<h2 id="其它动画"><a href="#其它动画" class="headerlink" title="其它动画"></a>其它动画</h2><h3 id="Lottie"><a href="#Lottie" class="headerlink" title="Lottie"></a>Lottie</h3><p>Lottie 是 Airbnb 开发的一款能够为原生应用添加动画效果的开源工具。Lottie 目前提供了 iOS, Android, 和 React Native 版本，能够实时渲染 After Effects 动画特效。</p>
<p>Android : <a target="_blank" rel="noopener" href="https://github.com/airbnb/lottie-android"> https://github.com/airbnb/lottie-android</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// lottie</span><br><span class="line">implementation &quot;com.airbnb.android:lottie:3.4.1&quot;</span><br></pre></td></tr></table></figure>

<p>src/main/assets 存放 json 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lottieAnimationView = findViewById(R.id.lottieAnimationView);</span><br><span class="line">lottieAnimationView.setImageAssetsFolder(&quot;images&quot;);</span><br><span class="line">lottieAnimationView.setAnimation(&quot;data.json&quot;);</span><br><span class="line">lottieAnimationView.loop(true);</span><br><span class="line">lottieAnimationView.playAnimation();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.airbnb.lottie.LottieAnimationView</span><br><span class="line">            android:id=&quot;@+id/lottieAnimationView&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            app:lottie_fileName=&quot;hello-world.json&quot;</span><br><span class="line">            app:lottie_loop=&quot;true&quot;</span><br><span class="line">            app:lottie_autoPlay=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>监听动画进度 [0,1]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lottieAnimationView.addAnimatorUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</span><br><span class="line">            // 判断动画加载结束</span><br><span class="line">            if (valueAnimator.getAnimatedFraction() == 1f) &#123;</span><br><span class="line">                if (dialog.isShowing() &amp;&amp; getActivity() != null)</span><br><span class="line">                    dialog.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>暂停/取消/播放</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lottieAnimationView.pauseAnimation();</span><br><span class="line">lottieAnimationView.cancelAnimation();</span><br><span class="line">lottieAnimationView.playAnimation();</span><br></pre></td></tr></table></figure>

<h3 id="SpringAnimation"><a href="#SpringAnimation" class="headerlink" title="SpringAnimation"></a>SpringAnimation</h3><p><a class="link"   target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0330/7757.html" >SpringAnimation详解－Android<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="ViewPager切换动画"><a href="#ViewPager切换动画" class="headerlink" title="ViewPager切换动画"></a>ViewPager切换动画</h3><p>ViewPager有个方法叫做：setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer) 用于设置ViewPager切换时的动画效果，并且google官方还给出了两个示例：DepthPageTransformer 和 ZoomOutPageTransformer。</p>
<p>DepthPageTransformer：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class DepthPageTransformer implements ViewPager.PageTransformer &#123;</span><br><span class="line">    private static final float MIN_SCALE = 0.75f;</span><br><span class="line"> </span><br><span class="line">    public void transformPage(View view, float position) &#123;</span><br><span class="line">        int pageWidth = view.getWidth();</span><br><span class="line"> </span><br><span class="line">        if (position &lt; -1) &#123; // [-Infinity,-1)</span><br><span class="line">            // This page is way off-screen to the left.</span><br><span class="line">            view.setAlpha(0);</span><br><span class="line"> </span><br><span class="line">        &#125; else if (position &lt;= 0) &#123; // [-1,0]</span><br><span class="line">            // Use the default slide transition when moving to the left page</span><br><span class="line">            view.setAlpha(1);</span><br><span class="line">            view.setTranslationX(0);</span><br><span class="line">            view.setScaleX(1);</span><br><span class="line">            view.setScaleY(1);</span><br><span class="line"> </span><br><span class="line">        &#125; else if (position &lt;= 1) &#123; // (0,1]</span><br><span class="line">            // Fade the page out.</span><br><span class="line">            view.setAlpha(1 - position);</span><br><span class="line"> </span><br><span class="line">            // Counteract the default slide transition</span><br><span class="line">            view.setTranslationX(pageWidth * -position);</span><br><span class="line"> </span><br><span class="line">            // Scale the page down (between MIN_SCALE and 1)</span><br><span class="line">            float scaleFactor = MIN_SCALE</span><br><span class="line">                    + (1 - MIN_SCALE) * (1 - Math.abs(position));</span><br><span class="line">            view.setScaleX(scaleFactor);</span><br><span class="line">            view.setScaleY(scaleFactor);</span><br><span class="line"> </span><br><span class="line">        &#125; else &#123; // (1,+Infinity]</span><br><span class="line">            // This page is way off-screen to the right.</span><br><span class="line">            view.setAlpha(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mViewPager.setPageTransformer(true, new DepthPageTransformer());</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20141028231742399"></p>
<p>自定义PageTransformer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface PageTransformer &#123;</span><br><span class="line">       /**</span><br><span class="line">        * Apply a property transformation to the given page.</span><br><span class="line">        *</span><br><span class="line">        * @param page Apply the transformation to this page</span><br><span class="line">        * @param position Position of page relative to the current front-and-center</span><br><span class="line">        *                 position of the pager. 0 is front and center. 1 is one full</span><br><span class="line">        *                 page position to the right, and -1 is one page position to the left.</span><br><span class="line">        */</span><br><span class="line">       public void transformPage(View page, float position);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>直播间左滑切出页面的PageTransformer，原页面原地不动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class LivePagerTransformer implements ViewPager.PageTransformer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transformPage(@NonNull View view, float position) &#123;</span><br><span class="line">        onTransform(view, position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onTransform(@NonNull View view, float position) &#123;</span><br><span class="line">        Context context = view.getContext();</span><br><span class="line">        if (context == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String tag = &quot;&quot;;</span><br><span class="line">        if (view.getTag() != null) &#123;</span><br><span class="line">            tag = view.getTag().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            LogUtil.i(&quot;LivePagerTransformer&quot;, &quot;onTransform--&gt;&gt;view:&quot; + tag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (tag.equals(context.getString(R.string.live_room_tag))) &#123;</span><br><span class="line">            float scale = position &lt; 0 ? position + 1f : Math.abs(1f - position);</span><br><span class="line">            if (BuildConfig.DEBUG) &#123;</span><br><span class="line">                LogUtil.i(&quot;LivePagerTransformer&quot;, &quot;onTransform--&gt;&gt;scale:&quot; + scale);</span><br><span class="line">            &#125;</span><br><span class="line">            float width = view.getWidth();</span><br><span class="line">            float translationX = Math.abs(width - width * scale);</span><br><span class="line">            if (BuildConfig.DEBUG) &#123;</span><br><span class="line">                LogUtil.i(&quot;LivePagerTransformer&quot;, &quot;onTransform--&gt;&gt;translationX:&quot; + translationX);</span><br><span class="line">            &#125;</span><br><span class="line">            view.setTranslationX(translationX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/lmj623565791/article/details/40411921/" >Android 实现个性的ViewPager切换动画 实战PageTransformer<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/harvic880925/article/details/39996643" >动画篇（一）——alpha、scale、translate、rotate、set的xml属性及用法<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6893699748373463047" >动画 | Android 补间动画 浅析<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/93abf14de14d" >Android补间动画原理分析<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/420629118c10" >Android 动画总结<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/harvic880925/article/details/50752838" >PropertyValuesHolder与Keyframe<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6844903614771625992" >Android 转场动画<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/6880409898363027463" >优雅的转场动画之 Transition<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/282d098cf928" >Lottie - 让复杂动画如此简单<i class="fas fa-external-link-alt"></i></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2021/07/31/%E5%8A%A8%E7%94%BBAnimation/" data-id="ckrrjpal8001pu01n9v6f0sva" data-title="动画Animation" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breewf.github.io/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-judge-app-background" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2016/09/11/judge-app-background/" class="article-date">
  <time class="dt-published" datetime="2016-09-11T12:04:14.000Z" itemprop="datePublished">2016-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2016/09/11/judge-app-background/">判断App位于前台或后台的6种方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>原文链接：<a target="_blank" rel="noopener" href="https://github.com/wenmingvs/AndroidProcess">AndroidProcess</a></p>
<h1 id="AndroidProcess"><a href="#AndroidProcess" class="headerlink" title="AndroidProcess"></a>AndroidProcess</h1><p>提供6种方法来判断App处于前台还是后台，并且封装成工具类供大家使用</p>
<p>最后一种方法堪称Android黑科技（非原创），既可以突破Android5.0以上的权限封锁，获取任意前台App的包名，又不需要权限，此方法并非我原创，原作者是国外的大神，<a target="_blank" rel="noopener" href="https://github.com/jaredrummler/AndroidProcesses">GitHub项目在这里</a>，也一并加入到工程中，供大家做全面的参考选择   </p>
<p><strong>2016.2.11更新——感谢<a class="link"   target="_blank" rel="noopener" href="http://weibo.com/hatewx?refer_flag=1005050005_" >@EffectiveMatrix<i class="fas fa-external-link-alt"></i></a>大神带来的新的判断前后台的方法</strong>  </p>
<h2 id="预览图"><a href="#预览图" class="headerlink" title="预览图"></a>预览图</h2><p><img src="http://ww2.sinaimg.cn/large/691cc151gw1f09z4gz35mg20bc0h01kx.gif" alt="enter image description here"></p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>传入Context参数与想要判断是否位于前台的App的包名,会返回ture或者false表示App是否位于前台</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//六种方法任选其一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法一</span></span><br><span class="line">Boolean isForeground = BackgroundUtil.getRunningTask(context, packageName);</span><br><span class="line"><span class="comment">//使用方法二</span></span><br><span class="line">Boolean isForeground = BackgroundUtil.getRunningAppProcesses(context, packageName);</span><br><span class="line"><span class="comment">//使用方法三</span></span><br><span class="line">Boolean isForeground = BackgroundUtil.getApplicationValue(context);</span><br><span class="line"><span class="comment">//使用方法四</span></span><br><span class="line">Boolean isForeground = BackgroundUtil.queryUsageStats(context, packageName);</span><br><span class="line"><span class="comment">//使用方法五</span></span><br><span class="line">Boolean isForeground = BackgroundUtil.getFromAccessibilityService(context, packageName);</span><br><span class="line"><span class="comment">//使用方法六</span></span><br><span class="line">Boolean isForeground = BackgroundUtil.getLinuxCoreInfo(context, packageName);</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/breewf.github.io/2016/09/11/judge-app-background/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2016/09/11/judge-app-background/" data-id="ckrrjpakh000ku01ng1ab04sj" data-title="判断App位于前台或后台的6种方法" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breewf.github.io/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-adb-command-data" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2016/09/10/adb-command-data/" class="article-date">
  <time class="dt-published" datetime="2016-09-10T03:14:14.000Z" itemprop="datePublished">2016-09-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2016/09/10/adb-command-data/">ADB命令学习资料</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>ADB即Android Debug Bridge，安卓开发、测试过程中强大的命令调试工具，熟练掌握ADB命令可以提高开发效率。</p>
<p><strong>ADB学习资料整理：</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mzlogin/awesome-adb#%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95">Awesome Adb——一份超全超详细的 ADB 用法大全</a></p>
<p><a class="link"   target="_blank" rel="noopener" href="http://yifeiyuan.me/2016/06/30/ADB%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/" >那些做Android开发必须知道的ADB命令<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="http://stormzhang.com/2016/09/08/common-adb-commands/" >你应该知道的一些 ADB 命令<i class="fas fa-external-link-alt"></i></a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ZQiang94/StudyRecords/blob/master/other/src/main/java/com/other/adb%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.md">adb 命令行的使用记录</a></p>
<p><a class="link"   target="_blank" rel="noopener" href="http://www.jianshu.com/p/5980c8c282ef" >Android adb你真的会用吗?<i class="fas fa-external-link-alt"></i></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2016/09/10/adb-command-data/" data-id="ckrrjpak30003u01n9zts4tcq" data-title="ADB命令学习资料" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breewf.github.io/tags/%E5%85%B6%E5%AE%83/" rel="tag">其它</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-more-channel-apk" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2016/08/18/more-channel-apk/" class="article-date">
  <time class="dt-published" datetime="2016-08-18T05:47:12.000Z" itemprop="datePublished">2016-08-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2016/08/18/more-channel-apk/">Gradle、Python脚本多渠道自动化打包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么要多渠道打包？"><a href="#为什么要多渠道打包？" class="headerlink" title="为什么要多渠道打包？"></a>为什么要多渠道打包？</h2><p>众所周知，由于Google play在国内无法使用，国内Android应用市场群雄纷争，存在着众多的应用市场，在不同的市场可能有着不同的统计需求，需要为每个应用市场的Android包设定一个可以区分应用市场的标识，为此Android开发人员需要为每个应用市场发布一个安装包（渠道包），这就是为什么Android需要多渠道打包。</p>
<h2 id="使用gradle打包"><a href="#使用gradle打包" class="headerlink" title="使用gradle打包"></a>使用gradle打包</h2><h3 id="配置AndroidManifest-xml"><a href="#配置AndroidManifest-xml" class="headerlink" title="配置AndroidManifest.xml"></a>配置AndroidManifest.xml</h3><p>在Androidmanifest.xml中定义mate-data标签：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:Android=<span class="string">&quot;http://schemas.Android.com/apk/res/Android&quot;</span>    </span><br><span class="line">    package=<span class="string">&quot;com.package.name&quot;</span>&gt;    </span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">application</span>&gt;</span>    </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;UMENG_CHANNEL&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;xiaomi&quot;</span> /&gt;</span>   </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span>    </span><br><span class="line">&lt;/manifest&gt; </span><br></pre></td></tr></table></figure>
<p>如果不使用多渠道打包方法，那就需要我们手动一个一个去修改value中的值，比如xiaomi，360，qq，wandoujia等等。<br>使用多渠道打包的方式，就需要把上面的value配置成下面的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data android:name=<span class="string">&quot;UMENG_CHANNEL&quot;</span> android:value=<span class="string">&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>其中${UMENG_CHANNEL_VALUE}中的值就是你在gradle中自定义配置的值。</p>
        
          <p class="article-more-link">
            <a href="/breewf.github.io/2016/08/18/more-channel-apk/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2016/08/18/more-channel-apk/" data-id="ckrrjpakj000ru01n65p36jk5" data-title="Gradle、Python脚本多渠道自动化打包" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breewf.github.io/tags/Gradle/" rel="tag">Gradle</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-android-splash" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2016/08/16/android-splash/" class="article-date">
  <time class="dt-published" datetime="2016-08-16T10:25:27.000Z" itemprop="datePublished">2016-08-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2016/08/16/android-splash/">APP闪屏页的正确打开方式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>闪屏页（Splash），顾名思义，就是一闪而过的页面，当然，它大多时候可能并不是一闪而过，而是要我们等待数秒，因为我们的app在打开、初始化、加载的过程中都需要一定的时间，尤其是首次启动（冷启动）或者手机性能较差的时候耗时更加明显，这时候我们什么也看不到。与其毫无意义的等待（黑屏or白屏），何不展示一些有趣或者有意思的东西呢？所以闪屏页一般被用来展示公司Logo、标语或者App的特性等，当然，展示广告的就比较坑啦。那么问题来啦，既然我都设置了闪屏页，为什么我的app启动的时候还是会黑屏或白屏呢？</p>
</blockquote>
<h2 id="问题由来：Starting-Window"><a href="#问题由来：Starting-Window" class="headerlink" title="问题由来：Starting Window"></a>问题由来：Starting Window</h2><p>当打开一个Activity时，如果这个Activity所属的应用还没有在运行，系统会为这个Activity所属的应用创建一个进程，但进程的创建与初始化都需要时间，在这个动作完成之前，如果初始化的时间过长，屏幕上可能没有任何动静，用户会以为没有点到相应的按钮。所以既不能停在原来的地方但又无法显示应用程序，怎么办呢？这就有了Starting Window（也称之为Preview Window）。</p>
        
          <p class="article-more-link">
            <a href="/breewf.github.io/2016/08/16/android-splash/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2016/08/16/android-splash/" data-id="ckrrjpak70007u01n9a0mhrv5" data-title="APP闪屏页的正确打开方式" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breewf.github.io/tags/%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96/" rel="tag">性能&优化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-memory-leak" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2016/08/07/memory-leak/" class="article-date">
  <time class="dt-published" datetime="2016-08-07T07:05:27.000Z" itemprop="datePublished">2016-08-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2016/08/07/memory-leak/">Android内存泄漏</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>内存泄露，简单的说，就是该被释放的内存没有被释放，一直被某个或某些实例所引用但不能被使用，导致GC不能回收，造成内存泄漏。总结的说，可以理解为长生命周期的对象一直持有短生命周期对象的引用，导致短生命周期对象一直被引用而无法被GC回收，内存泄漏是造成OOM的主要原因之一，当一个应用中产生的内存泄漏比较多时，就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>
<h2 id="安卓中常见的内存泄漏场景"><a href="#安卓中常见的内存泄漏场景" class="headerlink" title="安卓中常见的内存泄漏场景"></a>安卓中常见的内存泄漏场景</h2><h3 id="单例造成内存泄漏"><a href="#单例造成内存泄漏" class="headerlink" title="单例造成内存泄漏"></a>单例造成内存泄漏</h3><p>因为单例模式有其静态的特点，其生命周期和应用一样长，如果单例对象中包含了一个其他对象的引用，那么即使这个对象不再使用，依然存在一个单例对象引用它，造成无法回收。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    private Context context;</span><br><span class="line">    private <span class="function"><span class="title">AppManager</span>(<span class="params">Context context</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">static</span> AppManager <span class="function"><span class="title">getInstance</span>(<span class="params">Context context</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/breewf.github.io/2016/08/07/memory-leak/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2016/08/07/memory-leak/" data-id="ckrrjpaki000nu01nf7kcdva2" data-title="Android内存泄漏" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breewf.github.io/tags/%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96/" rel="tag">性能&优化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hexo-simple-use" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2016/06/13/hexo-simple-use/" class="article-date">
  <time class="dt-published" datetime="2016-06-13T03:03:09.000Z" itemprop="datePublished">2016-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2016/06/13/hexo-simple-use/">Hexo常用命令备忘</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>$ hexo g #生成<br>$ hexo s #本地预览</p>
<p>访问本地页面：<a class="link"   target="_blank" rel="noopener" href="http://localhost:4000/" >http://localhost:4000/<i class="fas fa-external-link-alt"></i></a></p>
<p>$ hexo d #部署</p>
<p>hexo new “postName” #新建文章</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2016/06/13/hexo-simple-use/" data-id="ckrrjpake000fu01n8q4d9o39" data-title="Hexo常用命令备忘" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breewf.github.io/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rxjava-production-line" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2016/04/28/rxjava-production-line/" class="article-date">
  <time class="dt-published" datetime="2016-04-28T07:49:16.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2016/04/28/rxjava-production-line/">用流水线的方式来理解RxJava的概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>原文链接 : <a class="link"   target="_blank" rel="noopener" href="http://www.thedroidsonroids.com/blog/android/rxjava-production-line/" >RxJava – the production line<i class="fas fa-external-link-alt"></i></a></li>
<li>原文作者 : <a href="">Mateusz Budzar</a></li>
<li>译文出自 : <a target="_blank" rel="noopener" href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li>
<li>译者 : <a target="_blank" rel="noopener" href="https://github.com/Sausure">Sausure</a></li>
<li>校对者 : <a target="_blank" rel="noopener" href="https://github.com/huanglizhuo">lizhuo</a>, <a target="_blank" rel="noopener" href="https://github.com/rockzhai">Rocky</a></li>
</ul>
<h2 id="为什么另写一篇-RxJava-的文章"><a href="#为什么另写一篇-RxJava-的文章" class="headerlink" title="为什么另写一篇 RxJava 的文章?"></a>为什么另写一篇 RxJava 的文章?</h2><p>已经有很多<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxJava"> RxJava </a>的文章通过例子阐述了什么是 RxJava 以及怎么去用，但它们大多数只有代码。虽然也会通过类比来解释，例如最出名的就是“流”。通常情况下代码能完美地让人理解（我们都是程序员，对吧？），但是 RxJava 十分不同于以往的 Android 开发。在最开始时通过代码是很难让人理解的，用“流”来类比并不足够，即使是<a class="link"   target="_blank" rel="noopener" href="http://rxmarbles.com/" > marbles <i class="fas fa-external-link-alt"></i></a>的例子也还远远不够。我可以保证自己能理解，但对于别人，老实说，难道你们不需要更多结合实际的例子？难道你们不想在脑海中举一个例子来让自己更好地理解 RxJava 吗？我做了，并且我想和你们分享。</p>
<h2 id="工厂流水线"><a href="#工厂流水线" class="headerlink" title="工厂流水线"></a>工厂流水线</h2><p>好吧，我说谎了。为了理解 RxJava，我在脑海里举了不仅仅一个例子。例如我尝试观察动物园笼子的动物，尝试观察河流里的鱼，也尝试去观察蝙蝠侠里的犯罪（额，这不是现实生活中的，但不失为一个很好的例子）。但我还是认为工厂流水线是最好的例子。</p>
<p><img src="http://ww1.sinaimg.cn/large/a490147fjw1f2ty3u29rzj20sg0fx0t6.jpg"></p>
        
          <p class="article-more-link">
            <a href="/breewf.github.io/2016/04/28/rxjava-production-line/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2016/04/28/rxjava-production-line/" data-id="ckrrjpakk000uu01navryafpg" data-title="用流水线的方式来理解RxJava的概念" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breewf.github.io/tags/RxJava/" rel="tag">RxJava</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-app-dev-third-sup" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breewf.github.io/2016/04/06/app-dev-third-sup/" class="article-date">
  <time class="dt-published" datetime="2016-04-06T05:55:04.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breewf.github.io/2016/04/06/app-dev-third-sup/">移动开发优秀三方支持</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>1.友盟：<a class="link"   target="_blank" rel="noopener" href="http://www.umeng.com/" >http://www.umeng.com/<i class="fas fa-external-link-alt"></i></a><br>友盟涵盖应用统计、消息推送、即时通讯、社会化分享、自动更新等功能，可以说是大而全。<br>2.Talkingdata：<a class="link"   target="_blank" rel="noopener" href="https://www.talkingdata.com/" >https://www.talkingdata.com/<i class="fas fa-external-link-alt"></i></a><br>Talkingdata提供应用统计分析、游戏运营分析、移动广告检测等服务。</p>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>1.个推：<a class="link"   target="_blank" rel="noopener" href="http://www.getui.com/" >http://www.getui.com/<i class="fas fa-external-link-alt"></i></a><br>2.极光推送：<a class="link"   target="_blank" rel="noopener" href="https://www.jpush.cn/" >https://www.jpush.cn/<i class="fas fa-external-link-alt"></i></a><br>3.友盟推送：<a class="link"   target="_blank" rel="noopener" href="http://www.umeng.com/push" >http://www.umeng.com/push<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="社会化分享"><a href="#社会化分享" class="headerlink" title="社会化分享"></a>社会化分享</h3><p>1.Mob ShareSDK：<a class="link"   target="_blank" rel="noopener" href="http://www.mob.com/#/" >http://www.mob.com/#/<i class="fas fa-external-link-alt"></i></a><br>Mob还提供短信验证SDK，MobAPI(包括天气查询、邮编查询、号码归属地查询以及即将上线的车辆违章查询等API接口)。<br>2.友盟社会化分享：<a class="link"   target="_blank" rel="noopener" href="http://www.umeng.com/social" >http://www.umeng.com/social<i class="fas fa-external-link-alt"></i></a></p>
        
          <p class="article-more-link">
            <a href="/breewf.github.io/2016/04/06/app-dev-third-sup/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://breewf.github.io/2016/04/06/app-dev-third-sup/" data-id="ckrrjpak90009u01n4p9779ch" data-title="移动开发优秀三方支持" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breewf.github.io/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/breewf.github.io/page/2/">2</a><a class="extend next" rel="next" href="/breewf.github.io/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/breewf.github.io/categories/%E5%AE%89%E5%8D%93/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/breewf.github.io/categories/%E6%96%87%E7%AB%A0/">文章</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/breewf.github.io/tags/Gradle/" rel="tag">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breewf.github.io/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breewf.github.io/tags/RxJava/" rel="tag">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breewf.github.io/tags/View/" rel="tag">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breewf.github.io/tags/%E5%85%B6%E5%AE%83/" rel="tag">其它</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breewf.github.io/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breewf.github.io/tags/%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96/" rel="tag">性能&优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breewf.github.io/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breewf.github.io/tags/%E6%96%87%E7%AB%A0/" rel="tag">文章</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/breewf.github.io/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/breewf.github.io/tags/Retrofit/" style="font-size: 13.33px;">Retrofit</a> <a href="/breewf.github.io/tags/RxJava/" style="font-size: 16.67px;">RxJava</a> <a href="/breewf.github.io/tags/View/" style="font-size: 10px;">View</a> <a href="/breewf.github.io/tags/%E5%85%B6%E5%AE%83/" style="font-size: 10px;">其它</a> <a href="/breewf.github.io/tags/%E5%8A%A8%E7%94%BB/" style="font-size: 10px;">动画</a> <a href="/breewf.github.io/tags/%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96/" style="font-size: 13.33px;">性能&优化</a> <a href="/breewf.github.io/tags/%E6%80%BB%E7%BB%93/" style="font-size: 20px;">总结</a> <a href="/breewf.github.io/tags/%E6%96%87%E7%AB%A0/" style="font-size: 10px;">文章</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/breewf.github.io/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breewf.github.io/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breewf.github.io/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breewf.github.io/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breewf.github.io/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breewf.github.io/archives/2016/03/">三月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/breewf.github.io/2021/07/31/ViewBinding/">ViewBinding</a>
          </li>
        
          <li>
            <a href="/breewf.github.io/2021/07/31/%E5%8A%A8%E7%94%BBAnimation/">动画Animation</a>
          </li>
        
          <li>
            <a href="/breewf.github.io/2016/09/11/judge-app-background/">判断App位于前台或后台的6种方法</a>
          </li>
        
          <li>
            <a href="/breewf.github.io/2016/09/10/adb-command-data/">ADB命令学习资料</a>
          </li>
        
          <li>
            <a href="/breewf.github.io/2016/08/18/more-channel-apk/">Gradle、Python脚本多渠道自动化打包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 haiygao<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/breewf.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/breewf.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/breewf.github.io/js/jquery-3.4.1.min.js"></script>



  
<script src="/breewf.github.io/fancybox/jquery.fancybox.min.js"></script>




<script src="/breewf.github.io/js/script.js"></script>





  </div>
</body>
</html>