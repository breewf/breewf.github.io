<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="白日梦重度患者">
    <meta name="author" content="breewf">
    
    <title>
        
            四大组件_Service |
        
        breewf
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/10130323?s=400&u=90608a86412bc1da2ca6aafec22b20e068463ce8&v=4">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"github.com","root":"/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"https://avatars.githubusercontent.com/u/10130323?s=400&u=90608a86412bc1da2ca6aafec22b20e068463ce8&v=4","favicon":"https://avatars.githubusercontent.com/u/10130323?s=400&u=90608a86412bc1da2ca6aafec22b20e068463ce8&v=4","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                breewf
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">四大组件_Service</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="https://avatars.githubusercontent.com/u/10130323?s=400&u=90608a86412bc1da2ca6aafec22b20e068463ce8&v=4">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">breewf</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-08-06 15:22:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%AE%89%E5%8D%93/">安卓</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="什么是Service"><a href="#什么是Service" class="headerlink" title="什么是Service"></a>什么是Service</h2><p>Service是Android程序中四大基础组件之一，它和Activity一样都是Context的子类，只不过它没有UI界面，是在后台运行的组件。</p>
<p>Service(服务)是一个一种可以在后台执行长时间运行操作而<strong>没有用户界面的应用组件</strong>。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。</p>
<p>Service是Android中实现程序后台运行的解决方案，它非常适用于去执行那些不需要和用户交互而且还要求长期运行的任务。Service默认并不会运行在子线程中，它也不运行在一个独立的进程中，<strong>它同样执行在UI线程中</strong>，因此，<strong>不要在Service中执行耗时的操作</strong>，除非你在Service中创建了子线程来完成耗时操作。</p>
<h2 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h2><p><img src="https://user-gold-cdn.xitu.io/2020/2/21/17067228efe87a71"></p>
<blockquote>
<p>服务的整个生命周期从调用 onCreate() 开始起，到 onDestroy() 返回时结束。与 Activity 类似，服务也在 onCreate() 中完成初始设置，并在 onDestroy() 中释放所有剩余资源。例如，音乐播放服务可以在 onCreate() 中创建用于播放音乐的线程，然后在 onDestroy() 中停止该线程。</p>
<p>无论服务是通过 startService() 还是 bindService() 创建，都会调用 onCreate() 和 onDestroy() 方法。</p>
<p>服务的有效生命周期从调用 onStartCommand() 或 onBind() 方法开始。每种方法均有 Intent 对象，该对象分别传递自 startService() 或 bindService()。</p>
</blockquote>
<h3 id="startService-启动服务"><a href="#startService-启动服务" class="headerlink" title="startService() 启动服务"></a>startService() 启动服务</h3><p>当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。</p>
<blockquote>
<p>startService / stopService</p>
<p>生命周期顺序：onCreate-&gt;onStartCommand-&gt;onDestroy</p>
</blockquote>
<h4 id="OnCreate"><a href="#OnCreate" class="headerlink" title="OnCreate()"></a>OnCreate()</h4><p>系统在service第一次创建时执行此方法，来执行只运行一次的初始化工作。如果service已经运行，这个方法不会被调用。</p>
<h4 id="onStartCommand"><a href="#onStartCommand" class="headerlink" title="onStartCommand()"></a>onStartCommand()</h4><p>每次客户端调用startService()方法启动该Service都会回调该方法（多次调用）。一旦这个方法执行，service就启动并且在后台长期运行。通过调用stopSelf()或stopService()来停止服务。</p>
<h4 id="OnDestory"><a href="#OnDestory" class="headerlink" title="OnDestory()"></a>OnDestory()</h4><p>系统在service不再被使用并要销毁时调用此方法（一次调用）。service应在此方法中释放资源，比如线程，已注册的监听器等等，这是service收到的最后一个调用。</p>
<h3 id="bindService-绑定服务"><a href="#bindService-绑定服务" class="headerlink" title="bindService() 绑定服务"></a>bindService() 绑定服务</h3><p>当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<blockquote>
<p>bindService / unbindService</p>
<p>生命周期顺序：onCreate-&gt;onBind-&gt;onUnBind-&gt;onDestroy</p>
</blockquote>
<h4 id="onBind"><a href="#onBind" class="headerlink" title="onBind()"></a>onBind()</h4><p>当组件调用bindService()想要绑定到service时(比如想要执行进程间通信)系统调用此方法（一次调用，一旦绑定后，下次再调用bindService()不会回调该方法）。在你的实现中，你必须提供一个返回一个IBinder来以使客户端能够使用它与service通讯，<strong>你必须总是实现这个方法</strong>，但是如果你不允许绑定，那么你应返回null。</p>
<h4 id="onUnbind"><a href="#onUnbind" class="headerlink" title="onUnbind()"></a>onUnbind()</h4><p>当前组件调用unbindService()，想要解除与service的绑定时系统调用此方法（一次调用，一旦解除绑定后，下次再调用unbindService()会抛出异常）。</p>
<h2 id="Service注册"><a href="#Service注册" class="headerlink" title="Service注册"></a>Service注册</h2><p>Service在AndroidManifest.xml中的声明语法，其格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:enabled=[&quot;true&quot; | &quot;false&quot;]</span><br><span class="line">    android:exported=[&quot;true&quot; | &quot;false&quot;]</span><br><span class="line">    android:icon=&quot;drawable resource&quot;</span><br><span class="line">    android:isolatedProcess=[&quot;true&quot; | &quot;false&quot;]</span><br><span class="line">    android:label=&quot;string resource&quot;</span><br><span class="line">    android:name=&quot;string&quot;</span><br><span class="line">    android:permission=&quot;string&quot;</span><br><span class="line">    android:process=&quot;string&quot; &gt;</span><br><span class="line">    . . .</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>android:exported：代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用</li>
<li>android:name：对应Service类名</li>
<li>android:permission：权限声明</li>
<li>android:process：是否需要在单独的进程中运行，当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。</li>
<li>android:isolatedProcess ：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限，与其通信的唯一途径是通过服务的API(bind and start)。</li>
<li>android:enabled：是否可以被系统实例化，默认为 true。因为父标签也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。</li>
</ul>
<h2 id="Service用法"><a href="#Service用法" class="headerlink" title="Service用法"></a>Service用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 第一步：在AndroidManifest.xml中进行注册</span><br><span class="line">&lt;service android:name=&quot;. SimpleService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">// 第二步：启动</span><br><span class="line">① startService(Intent);</span><br><span class="line">② bindService(Intent, ServiceConnection, Int);</span><br><span class="line"></span><br><span class="line">// 第三步：解绑(使用bindService()启动时操作)</span><br><span class="line">unBindService(ServiceConnection);</span><br><span class="line"></span><br><span class="line">// 第四步：暂停</span><br><span class="line">stopService(Intent);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绑定服务时才会调用</span><br><span class="line">     * 必须要实现的方法  </span><br><span class="line">     * @param intent</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。</span><br><span class="line">     * 如果服务已在运行，则不会调用此方法。该方法只被调用一次</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        System.out.println(&quot;onCreate invoke&quot;);</span><br><span class="line">        super.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每次通过startService()方法启动Service时都会被回调。</span><br><span class="line">     * @param intent</span><br><span class="line">     * @param flags</span><br><span class="line">     * @param startId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        System.out.println(&quot;onStartCommand invoke&quot;);</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 服务销毁时的回调</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        System.out.println(&quot;onDestroy invoke&quot;);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="onStartCommand-1"><a href="#onStartCommand-1" class="headerlink" title="onStartCommand"></a>onStartCommand</h2><p>onStartCommand（Intent intent, int flags, int startId）方法有3个传入参数，它们的含义如下</p>
<h3 id="intent"><a href="#intent" class="headerlink" title="intent"></a>intent</h3><p>启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service</p>
<h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><p>表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有，它们具体含义如下：</p>
<ul>
<li>START_FLAG_REDELIVERY</li>
</ul>
<p>这个值代表了onStartCommand方法的返回值为<br>START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent是有值的。</p>
<ul>
<li>START_FLAG_RETRY</li>
</ul>
<p>该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。</p>
<h3 id="startId"><a href="#startId" class="headerlink" title="startId"></a>startId</h3><p>指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。</p>
<p>实际上onStartCommand的返回值int类型才是最最值得注意的，它有三种可选值， <strong>START_STICKY</strong>，<strong>START_NOT_STICKY</strong>，<strong>START_REDELIVER_INTENT</strong>，它们具体含义如下：</p>
<h3 id="START-STICKY"><a href="#START-STICKY" class="headerlink" title="START_STICKY"></a>START_STICKY</h3><p>当Service因内存不足而被系统kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand方法，但其中的Intent将是null，除非有挂起的Intent，如pendingintent，这个状态下比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。</p>
<h3 id="START-NOT-STICKY"><a href="#START-NOT-STICKY" class="headerlink" title="START_NOT_STICKY"></a>START_NOT_STICKY</h3><p>当Service因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。除非程序中再次调用startService启动此Service，这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p>
<h3 id="START-REDELIVER-INTENT"><a href="#START-REDELIVER-INTENT" class="headerlink" title="START_REDELIVER_INTENT"></a>START_REDELIVER_INTENT</h3><p>当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent均依次传递。与START_STICKY不同的是，其中的传递的Intent将是非空，是最后一次调用startService中的intent。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
<blockquote>
<p>由于每次启动服务（调用startService）时，onStartCommand方法都会被调用，因此我们可以通过该方法使用Intent给Service传递所需要的参数，然后在onStartCommand方法中处理事件，最后根据需求选择不同的Flag返回值，以达到对程序更友好的控制。</p>
</blockquote>
<h2 id="Activity和Service的通信"><a href="#Activity和Service的通信" class="headerlink" title="Activity和Service的通信"></a>Activity和Service的通信</h2><p>Activity和Service的通信其实就是基于IBinder来进行实现的。但是IBinder其实是一个接口，对我们而言一般使用它的实现类Binder并通过强制转换来完成操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Service方法继承</span><br><span class="line"> * onBind()是一个抽象方法。</span><br><span class="line"> */</span><br><span class="line">public class LocalService extends Service &#123;</span><br><span class="line">    private final IBinder binder = new ServiceBinder();</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class ServiceBinder extends Binder &#123;</span><br><span class="line">        LocalService getLocalService()&#123;</span><br><span class="line">            return LocalService.this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然需要通信，那我们总需要知道对方是谁，如果使用的是startService()，他是独立于Activity的，所以势必使用的是bindService()。</p>
<p>ServiceConnection</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * bindService()方法中的参数之一。</span><br><span class="line"> * 用于对service进行操作</span><br><span class="line"> */</span><br><span class="line">ServiceConnection connection = new ServiceConnection() &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 绑定服务的时候被回调，在这个方法获取绑定Service传递过来的IBinder对象，</span><br><span class="line">             * 通过这个IBinder对象，实现宿主和Service的交互。</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public void onServiceConnected(ComponentName name, IBinder binder) &#123;</span><br><span class="line">                // 基于Binder拿到我们要的Service</span><br><span class="line">                service = ((LocalService.ServiceBinder)binder).getLocalService();</span><br><span class="line">                // 干你需要干的事情</span><br><span class="line">            &#125;</span><br><span class="line">           /**</span><br><span class="line">             * 当取消绑定的时候被回调。但正常情况下是不被调用的，它的调用时机是当Service服务被意外销毁时，</span><br><span class="line">             * 例如内存的资源不足时这个方法才被自动调用。</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">                service = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>注意需要使用unbindService()方法来解绑服务。</p>
<h2 id="Service绑定服务"><a href="#Service绑定服务" class="headerlink" title="Service绑定服务"></a>Service绑定服务</h2><p>当Service处于绑定状态时，其代表着客户端-服务器接口中的服务器。当其他组件（如 Activity）绑定到服务时（有时我们可能需要从Activity组件中去调用Service中的方法），组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应，甚至可以通过绑定服务进行执行进程间通信 (即IPC)。</p>
<p>那么在提供绑定的服务时，该如何实现呢？实际上我们必须提供一个 IBinder接口的实现类，该类用以提供客户端用来与服务进行交互的编程接口，该接口可以通过三种方法定义接口：</p>
<ul>
<li>扩展 Binder 类</li>
</ul>
<p>如果服务是提供给自有应用专用的，并且Service(服务端)与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中以及Service 中可用的公共方法。如果我们的服务只是自有应用的后台工作线程，则优先采用这种方法。 不采用该方式创建接口的唯一原因是，服务被其他应用或不同的进程调用。</p>
<ul>
<li>使用 Messenger</li>
</ul>
<p>Messenger可以翻译为信使，通过它可以在不同的进程中共传递Message对象(Handler中的Messager，因此 Handler 是 Messenger 的基础)，在Message中可以存放我们需要传递的数据，然后在进程间传递。如果需要让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口，客户端就可利用 Message 对象向服务发送命令。同时客户端也可定义自有 Messenger，以便服务回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，也就是说Messenger是以串行的方式处理客户端发来的消息，这样我们就不必对服务进行线程安全设计了。</p>
<ul>
<li>使用 AIDL</li>
</ul>
<p>由于Messenger是以串行的方式处理客户端发来的消息，如果当前有大量消息同时发送到Service(服务端)，Service仍然只能一个个处理，这也就是Messenger跨进程通信的缺点了，因此如果有大量并发请求，Messenger就会显得力不从心了，这时AIDL（Android 接口定义语言）就派上用场了， 但实际上Messenger 的跨进程方式其底层实现 就是AIDL，只不过android系统帮我们封装成透明的Messenger罢了 。因此，如果我们想让服务同时处理多个请求，则应该使用 AIDL。 在此情况下，服务必须具备多线程处理能力，并采用线程安全式设计。使用AIDL必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，随后可在服务内对其进行扩展。</p>
<p>以上3种实现方式，我们可以根据需求自由的选择，但需要注意的是大多数应用“都不会”使用 AIDL 来创建绑定服务，因为它可能要求具备多线程处理能力，并可能导致实现的复杂性增加。因此，AIDL 并不适合大多数应用。</p>
<blockquote>
<p>IPC（Inter-Process Communication，进程间通信）</p>
</blockquote>
<h2 id="启动服务与绑定服务间的转换"><a href="#启动服务与绑定服务间的转换" class="headerlink" title="启动服务与绑定服务间的转换"></a>启动服务与绑定服务间的转换</h2><p>虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，也就是说，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是Android系统仅会为一个Service创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个Service实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况：</p>
<ul>
<li>先绑定服务后启动服务</li>
</ul>
<p>如果当前Service实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主（Activity）被销毁了，也不会影响服务的运行，服务还是会一直运行下去，直到调用停止服务或者内存不足时才会销毁该服务。</p>
<ul>
<li>先启动服务后绑定服务</li>
</ul>
<p>如果当前Service实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有Context调用了stopService()或是服务本身调用了stopSelf()方法抑或内存不足时才会销毁服务。</p>
<blockquote>
<p>以上两种情况显示出启动服务的优先级确实比绑定服务高一些。不过无论Service是处于启动状态还是绑定状态，或处于启动并且绑定状态，我们都可以像使用Activity那样通过调用 Intent 来使用服务(即使此服务来自另一应用)。 当然，我们也可以通过清单文件将服务声明为私有服务，阻止其他应用访问。最后这里有点需要特殊说明一下的，由于服务在其托管进程的主线程中运行（UI线程），它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何耗时事件或阻止性操作（例如 MP3 播放或联网）时，则应在服务内创建新线程来完成这项工作，简而言之，耗时操作应该另起线程执行。只有通过使用单独的线程，才可以降低发生“应用无响应”(ANR) 错误的风险，这样应用的主线程才能专注于用户与 Activity 之间的交互， 以达到更好的用户体验。</p>
</blockquote>
<h2 id="前台服务以及通知发送"><a href="#前台服务以及通知发送" class="headerlink" title="前台服务以及通知发送"></a>前台服务以及通知发送</h2><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，状态栏位于“正在进行”标题下方，这意味着除非服务停止或从前台删除，否则不能清除通知。例如将从服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。如果需要设置服务运行于前台， 我们该如何才能实现呢？Android官方给我们提供了两个方法，分别是startForeground()和stopForeground()，这两个方式解析如下：</p>
<ul>
<li>startForeground(int id, Notification notification)</li>
</ul>
<p>该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。</p>
<ul>
<li>stopForeground(boolean removeNotification)</li>
</ul>
<p>该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true为删除。 注意该方法并不会停止服务，但是，如果服务正在前台运行时将其停止，则通知也会被删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class ForegroundService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * id不可设置为0,否则不能设置为前台service</span><br><span class="line">     */</span><br><span class="line">    private static final int NOTIFICATION_DOWNLOAD_PROGRESS_ID = 0x0001;</span><br><span class="line"></span><br><span class="line">    private boolean isRemove=false;//是否需要移除</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Notification</span><br><span class="line">     */</span><br><span class="line">    public void createNotification()&#123;</span><br><span class="line">        //使用兼容版本</span><br><span class="line">        NotificationCompat.Builder builder=new NotificationCompat.Builder(this);</span><br><span class="line">        //设置状态栏的通知图标</span><br><span class="line">        builder.setSmallIcon(R.mipmap.ic_launcher);</span><br><span class="line">        //设置通知栏横条的图标</span><br><span class="line">        builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.screenflash_logo));</span><br><span class="line">        //禁止用户点击删除按钮删除</span><br><span class="line">        builder.setAutoCancel(false);</span><br><span class="line">        //禁止滑动删除</span><br><span class="line">        builder.setOngoing(true);</span><br><span class="line">        //右上角的时间显示</span><br><span class="line">        builder.setShowWhen(true);</span><br><span class="line">        //设置通知栏的标题内容</span><br><span class="line">        builder.setContentTitle(&quot;I am Foreground Service!!!&quot;);</span><br><span class="line">        //创建通知</span><br><span class="line">        Notification notification = builder.build();</span><br><span class="line">        //设置为前台服务</span><br><span class="line">        startForeground(NOTIFICATION_DOWNLOAD_PROGRESS_ID,notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        int i=intent.getExtras().getInt(&quot;cmd&quot;);</span><br><span class="line">        if(i==0)&#123;</span><br><span class="line">            if(!isRemove) &#123;</span><br><span class="line">                createNotification();</span><br><span class="line">            &#125;</span><br><span class="line">            isRemove=true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //移除前台服务</span><br><span class="line">            if (isRemove) &#123;</span><br><span class="line">                stopForeground(true);</span><br><span class="line">            &#125;</span><br><span class="line">            isRemove=false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        //移除前台服务</span><br><span class="line">        if (isRemove) &#123;</span><br><span class="line">            stopForeground(true);</span><br><span class="line">        &#125;</span><br><span class="line">        isRemove=false;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ForegroundService类中，创建了一个notification的通知，并通过启动Service时传递过来的参数判断是启动前台服务还是关闭前台服务，最后在onDestroy方法被调用时，也应该移除前台服务。以下是ForegroundActivity的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ForegroundActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_foreground);</span><br><span class="line">        Button btnStart= (Button) findViewById(R.id.startForeground);</span><br><span class="line">        Button btnStop= (Button) findViewById(R.id.stopForeground);</span><br><span class="line">        final Intent intent = new Intent(this,ForegroundService.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        btnStart.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                intent.putExtra(&quot;cmd&quot;,0);//0,开启前台服务,1,关闭前台服务</span><br><span class="line">                startService(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        btnStop.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                intent.putExtra(&quot;cmd&quot;,1);//0,开启前台服务,1,关闭前台服务</span><br><span class="line">                startService(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务Service与线程Thread的区别"><a href="#服务Service与线程Thread的区别" class="headerlink" title="服务Service与线程Thread的区别"></a>服务Service与线程Thread的区别</h2><h3 id="两者概念的迥异"><a href="#两者概念的迥异" class="headerlink" title="两者概念的迥异"></a>两者概念的迥异</h3><ul>
<li>Thread 是程序执行的最小单元，它是分配CPU的基本单位，android系统中UI线程也是线程的一种，当然Thread还可以用于执行一些耗时异步的操作。</li>
<li>Service是Android的一种机制，服务是运行在主线程上的，它是由系统进程托管。它与其他组件之间的通信类似于client和server，是一种轻量级的IPC通信，这种通信的载体是binder，它是在linux层交换信息的一种IPC，而所谓的Service后台任务只不过是指没有UI的组件罢了。</li>
</ul>
<h3 id="两者的执行任务迥异"><a href="#两者的执行任务迥异" class="headerlink" title="两者的执行任务迥异"></a>两者的执行任务迥异</h3><ul>
<li>在android系统中，线程一般指的是工作线程(即后台线程)，而主线程是一种特殊的工作线程，它负责将事件分派给相应的用户界面小工具，如绘图事件及事件响应，因此为了保证应用 UI 的响应能力主线程上不可执行耗时操作，如果执行的操作不能很快完成，则应确保它们在单独的工作线程执行。</li>
<li>Service 则是android系统中的组件，一般情况下它运行于主线程中，因此在Service中是不可以执行耗时操作的，否则系统会报ANR异常，之所以称Service为后台服务，大部分原因是它本身没有UI，用户无法感知(当然也可以利用某些手段让用户知道)，但如果需要让Service执行耗时任务，可在Service中开启单独线程去执行。</li>
</ul>
<h3 id="两者使用场景"><a href="#两者使用场景" class="headerlink" title="两者使用场景"></a>两者使用场景</h3><ul>
<li>当要执行耗时的网络或者数据库查询以及其他阻塞UI线程或密集使用CPU的任务时，都应该使用工作线程(Thread)，这样才能保证UI线程不被占用而影响用户体验。</li>
<li>在应用程序中，如果需要长时间的在后台运行，而且不需要交互的情况下，使用服务。比如播放音乐，通过Service+Notification方式在后台执行同时在通知栏显示。</li>
</ul>
<h3 id="两者的最佳使用方式"><a href="#两者的最佳使用方式" class="headerlink" title="两者的最佳使用方式"></a>两者的最佳使用方式</h3><p>在大部分情况下，Thread和Service都会结合着使用，比如下载文件，一般会通过Service在后台执行+Notification在通知栏显示+Thread异步下载，再如应用程序会维持一个Service来从网络中获取推送服务。在Android官方看来也是如此，所以官网提供了一个Thread与Service的结合来方便我们执行后台耗时任务，它就是<strong>IntentService</strong>，当然 IntentService并不适用于所有的场景，但它的优点是使用方便、代码简洁，不需要我们创建Service实例和创建线程，某些场景下还是非常赞的！由于IntentService是单个worker thread，所以任务需要排队，因此不适合大多数的多任务情况。</p>
<h2 id="Service总结和一些问题"><a href="#Service总结和一些问题" class="headerlink" title="Service总结和一些问题"></a>Service总结和一些问题</h2><h3 id="Android-5-0以上的隐式启动问题"><a href="#Android-5-0以上的隐式启动问题" class="headerlink" title="Android 5.0以上的隐式启动问题"></a>Android 5.0以上的隐式启动问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//显示启动</span><br><span class="line">Intent intent = new Intent(this,ForegroundService.class);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure>

<p>隐式启动需要设置一个Action，我们可以把Action的名字设置成Service的全路径名字，在这种情况下android:exported默认为true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent serviceIntent = new Intent(); </span><br><span class="line">serviceIntent.setAction(&quot;com.android.ForegroundService&quot;);</span><br><span class="line">startService(serviceIntent);</span><br></pre></td></tr></table></figure>
<p>如果在同一个应用中，两者都可以用。在不同应用时，只能用隐式启动。</p>
<p>Android 5.0之后google出于安全的角度禁止了隐式声明Intent来启动Service。如果使用隐式启动Service，会出没有指明Intent的错误，如下：</p>
<p><img src="https://img-blog.csdn.net/20161004175047087"></p>
<p>主要原因我们可以从源码中找到，这里看看Android 4.4的ContextImpl源码中的validateServiceIntent(Intent service)，可知如果启动service的intent的component和package都为空并且版本大于KITKAT的时候只是报出一个警报，告诉开发者隐式声明intent去启动Service是不安全的。</p>
<p><img src="https://img-blog.csdn.net/20161004175945195"></p>
<p>而在android5.0之后呢？</p>
<p><img src="https://img-blog.csdn.net/20161004180036774"></p>
<p>从源码可以看出如果启动service的intent的component和package都为空并且版本大于LOLLIPOP(5.0)的时候，直接抛出异常，该异常与之前隐式启动所报的异常是一致的。那么该如何解决呢？</p>
<ul>
<li>设置Action和packageName</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent serviceIntent = new Intent(); </span><br><span class="line">serviceIntent.setAction(&quot;com.android.ForegroundService&quot;);</span><br><span class="line">serviceIntent.setPackage(getPackageName());//设置应用的包名</span><br><span class="line">startService(serviceIntent);</span><br></pre></td></tr></table></figure>

<ul>
<li>将隐式启动转换为显示启动</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static Intent getExplicitIntent(Context context, Intent implicitIntent) &#123;</span><br><span class="line">    // Retrieve all services that can match the given intent</span><br><span class="line">     PackageManager pm = context.getPackageManager();</span><br><span class="line">     List&lt;ResolveInfo&gt; resolveInfo = pm.queryIntentServices(implicitIntent, 0);</span><br><span class="line">     // Make sure only one match was found</span><br><span class="line">     if (resolveInfo == null || resolveInfo.size() != 1) &#123;</span><br><span class="line">         return null;</span><br><span class="line">     &#125;</span><br><span class="line">     // Get component info and create ComponentName</span><br><span class="line">     ResolveInfo serviceInfo = resolveInfo.get(0);</span><br><span class="line">     String packageName = serviceInfo.serviceInfo.packageName;</span><br><span class="line">     String className = serviceInfo.serviceInfo.name;</span><br><span class="line">     ComponentName component = new ComponentName(packageName, className);</span><br><span class="line">     // Create a new intent. Use the old one for extras and such reuse</span><br><span class="line">     Intent explicitIntent = new Intent(implicitIntent);</span><br><span class="line">     // Set the component to be explicit</span><br><span class="line">     explicitIntent.setComponent(component);</span><br><span class="line">     return explicitIntent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent mIntent = new Intent();//辅助Intent</span><br><span class="line">mIntent.setAction(&quot;com.android.ForegroundService&quot;);</span><br><span class="line">Intent serviceIntent = new Intent(getExplicitIntent(this,mIntent));</span><br><span class="line">startService(serviceIntent);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>在ANR机制中，Service的响应时长不能超过20s，Service其实并不能进行耗时操作，但是如果加上了Thread进行异步处理，那么其实他还是可以进行耗时操作的。(具体看你怎么进行回答，主要还是一个知识点，<strong>Service运行在主线程</strong>)</p>
</blockquote>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/52709857" >关于Android Service真正的完全详解<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/52426425" >Android 多线程之 IntentService 完全详解<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/08/06/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6_ContentProvider/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">四大组件_ContentProvider</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/08/06/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6_Activity/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">四大组件_Activity</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">breewf</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFService"><span class="nav-number">1.</span> <span class="nav-text">什么是Service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.</span> <span class="nav-text">Service生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#startService-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.1.</span> <span class="nav-text">startService() 启动服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OnCreate"><span class="nav-number">2.1.1.</span> <span class="nav-text">OnCreate()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onStartCommand"><span class="nav-number">2.1.2.</span> <span class="nav-text">onStartCommand()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OnDestory"><span class="nav-number">2.1.3.</span> <span class="nav-text">OnDestory()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bindService-%E7%BB%91%E5%AE%9A%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.2.</span> <span class="nav-text">bindService() 绑定服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#onBind"><span class="nav-number">2.2.1.</span> <span class="nav-text">onBind()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onUnbind"><span class="nav-number">2.2.2.</span> <span class="nav-text">onUnbind()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service%E6%B3%A8%E5%86%8C"><span class="nav-number">3.</span> <span class="nav-text">Service注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service%E7%94%A8%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">Service用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#onStartCommand-1"><span class="nav-number">5.</span> <span class="nav-text">onStartCommand</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#intent"><span class="nav-number">5.1.</span> <span class="nav-text">intent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flags"><span class="nav-number">5.2.</span> <span class="nav-text">flags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#startId"><span class="nav-number">5.3.</span> <span class="nav-text">startId</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#START-STICKY"><span class="nav-number">5.4.</span> <span class="nav-text">START_STICKY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#START-NOT-STICKY"><span class="nav-number">5.5.</span> <span class="nav-text">START_NOT_STICKY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#START-REDELIVER-INTENT"><span class="nav-number">5.6.</span> <span class="nav-text">START_REDELIVER_INTENT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity%E5%92%8CService%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">6.</span> <span class="nav-text">Activity和Service的通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service%E7%BB%91%E5%AE%9A%E6%9C%8D%E5%8A%A1"><span class="nav-number">7.</span> <span class="nav-text">Service绑定服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E4%B8%8E%E7%BB%91%E5%AE%9A%E6%9C%8D%E5%8A%A1%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">8.</span> <span class="nav-text">启动服务与绑定服务间的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%8F%B0%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E9%80%9A%E7%9F%A5%E5%8F%91%E9%80%81"><span class="nav-number">9.</span> <span class="nav-text">前台服务以及通知发送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1Service%E4%B8%8E%E7%BA%BF%E7%A8%8BThread%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">服务Service与线程Thread的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E6%A6%82%E5%BF%B5%E7%9A%84%E8%BF%A5%E5%BC%82"><span class="nav-number">10.1.</span> <span class="nav-text">两者概念的迥异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%BF%A5%E5%BC%82"><span class="nav-number">10.2.</span> <span class="nav-text">两者的执行任务迥异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">10.3.</span> <span class="nav-text">两者使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E6%9C%80%E4%BD%B3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">10.4.</span> <span class="nav-text">两者的最佳使用方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service%E6%80%BB%E7%BB%93%E5%92%8C%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">Service总结和一些问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-5-0%E4%BB%A5%E4%B8%8A%E7%9A%84%E9%9A%90%E5%BC%8F%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="nav-number">11.1.</span> <span class="nav-text">Android 5.0以上的隐式启动问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">12.</span> <span class="nav-text">其它</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
